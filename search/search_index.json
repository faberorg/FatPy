{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FatPy","text":"<p>Welcome to FatPy, an open-source Python package for fatigue life evaluation of materials.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>FatPy is developed to assist researchers, engineers, and industry professionals in accurately assessing material fatigue life. Its modular architecture is designed to accommodate a variety of fatigue analysis methods, making it a versatile tool in the field of material science.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#core-modules","title":"Core Modules","text":"<ul> <li>Stress-Life     Stress-based fatigue assessment methods for estimating fatigue damage with corrections for various effects (stress concentration, size, surface quality, etc.)</li> <li>Strain-Life     Fatigue analysis using strain amplitude and cycles to failure relationships (\u03b5-N approaches) such as Coffin-Manson and Basquin laws, suited for low-cycle and transitional fatigue regimes</li> <li>Energy-Life     Fatigue analysis methods based on the relationship between strain energy density and number of cycles to failure</li> <li>Damage Cumulation     Various fatigue damage accumulation rules for variable amplitude loading, including linear models (Palmgren-Miner) and advanced non-linear approaches accounting for load sequence effects</li> <li>Decompositions     Methods for breaking down complex load signals into cycles, containing both uniaxial and multiaxial procedures</li> <li>Plane-Based Methods     Methods for processing stress tensor paths on material planes, providing infrastructure for critical-plane and integral prediction approaches</li> </ul>"},{"location":"#supporting-modules","title":"Supporting Modules","text":"<ul> <li>Material Laws     Functions dealing with various material constitutive laws and behavior models</li> <li>Structural Mechanics     Stress analysis and transformation utilities</li> <li>Utils     General utilities for mesh handling, signal processing, and data manipulation</li> </ul>"},{"location":"#installation","title":"Installation","text":"Using pipUsing uv <p>Install from PyPI via pip</p> <pre><code>pip install fatpy\n</code></pre> <p>Faster installation from PyPI</p> <pre><code>uv pip install fatpy\n</code></pre> Tip <p>To install package and add dependency to your project .toml file use:</p> <pre><code>uv add fatpy # Install from PyPI and add dependency \n</code></pre> <p>For detailed installation options, see the Installation Guide </p>"},{"location":"#the-faber-project","title":"The FABER Project","text":"<p>Background</p> <p>FatPy is a key initiative of Working Group 6 (WG6) within the FABER (Fatigue Benchmark Repository) project, operating under COST Action CA23109. The FABER project aims to create a comprehensive database of experimental fatigue data to enhance the accuracy of fatigue life predictions.</p> <p>Working Group 6 is specifically focused on developing open-source fatigue software, with FatPy being a flagship product of this endeavor.</p>"},{"location":"#faber-resources","title":"FABER Resources","text":"<ul> <li> Official Website</li> <li> FABER Newsletter</li> <li> LinkedIn Organization Page</li> <li> LinkedIn Group Page</li> </ul> <ul> <li>More about FABER </li> </ul>"},{"location":"#join-our-efforts","title":"Join Our Efforts","text":"<p>We warmly invite you to contribute to the development and enhancement of FatPy. Whether you're interested in coding, testing, documentation, or providing feedback, your participation is invaluable.</p>"},{"location":"#getting-involved","title":"Getting Involved","text":"<ul> <li> <p>Explore the Repository: Visit our  GitHub repository to access the source code.</p> </li> <li> <p>Contribute: Follow our  Contribution Guidelines to help improve FatPy.</p> </li> <li> <p>Collaborate: Join our  Discussions or  Report issues.</p> </li> </ul> <p>By participating, you'll be part of a collaborative effort to advance the field of material fatigue analysis. Stay tuned to the FatPy documentation for regular updates, tutorials, and community news as we work together to push the boundaries of fatigue research.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#contact","title":"Contact","text":"<p>Feel free to share your ideas, use these channels to contact us:</p> <ul> <li> Contact page</li> <li> Project GitHub repository</li> </ul>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p> Gooby - for his help with the documentation and the project in general.</p>"},{"location":"contact/","title":"Contact","text":"<p>You can connect and get involved with both FatPy and FABER COST in several ways!</p>"},{"location":"contact/#for-faber","title":"For FABER","text":"<p>Check out these resources:</p> <ul> <li> Official Website</li> <li> FABER Newsletter</li> <li> LinkedIn Organization Page</li> <li> LinkedIn Group Page</li> </ul> <ul> <li>More about FABER </li> </ul>"},{"location":"contact/#for-fatpy","title":"For FatPy","text":"<p>Use GitHub as a main way to collaborate, discuss and improve the FatPy package.</p> <ul> <li> <p>Explore the Repository: Visit our  GitHub repository to access the source code.</p> </li> <li> <p>Contribute: Follow our  Contribution Guidelines to help improve FatPy.</p> </li> <li> <p>Collaborate: Join our  Discussions or  Report issues.</p> </li> </ul> <p>You can also contact our team directly! Here is a list of active members:</p> Name Position Email Github Jan V\u00fdborn\u00fd Maintainer jan.vyborny2@gmail.com https://github.com/faberorg Oleh Venhryniuk Contributor olehvenhryniuk@gmail.com https://github.com/justOleh Tom\u00e1\u0161 Karas Contributor tomas.karas@fs.cvut.cz https://github.com/KarasTomas <p>Thank you for reaching out and contributing your ideas! Your feedback and suggestions help us grow and improve. We appreciate your involvement in the FatPy and FABER communities!</p>"},{"location":"faber_cost/","title":"FABER COST","text":"<p>\"Enhancing Fatigue Prediction Through Collaboration\"</p> <p>Fatigue Benchmark Repository</p> <p>FABER is a COST Action focused on creating a comprehensive fatigue data repository, enhancing prediction methods, and fostering collaboration among academia, industry, and developers for safer, cost-effective designs.</p>"},{"location":"faber_cost/#about-us","title":"About Us","text":"<p>FABER is committed to advancing fatigue research by fostering interdisciplinary collaboration. Our mission is to create open-access repositories of experimental data, computational tools, and standardized benchmarks that redefine engineering practices and enhance safety.</p> <ul> <li> Official Website</li> <li> FABER Newsletter</li> <li> LinkedIn Organization Page</li> <li> LinkedIn Group Page</li> </ul>"},{"location":"faber_cost/#building-the-future-of-fatigue-analysis","title":"Building the Future of Fatigue Analysis","text":"<p>The goal of the action presented in this project is to develop a global leading network of industry, academia and fatigue solver developers to build a fatigue benchmark repository that will allow all stakeholders to test the quality of fatigue prediction models and of their various implementations in either in-house software units or in purchased solvers.</p> <p>This would enhance EU competitivity, reduce research poverty and deliver safer components for citizens. The project will demonstrate that benchmarking is possible, and what level of result quality can be achieved. To quicken the development, validation and application process of new criteria, new fatigue software tool enabling large scale validation processes is to be developed.</p>"},{"location":"faber_cost/#advantages-of-faber-cost","title":"Advantages of FABER COST","text":"<p>FABER COST offers significant benefits by creating a centralized fatigue data repository, improving prediction accuracy, and fostering collaboration across academia, industry, and developers. This initiative enhances the reliability and efficiency of fatigue analysis, ensuring safer, more cost-effective engineering solutions. By supporting open science, FABER drives innovation and modernizes fatigue life prediction methods.</p>"},{"location":"faber_cost/#main-contacts-and-leadership","title":"Main Contacts and Leadership","text":"<p>Our team of researchers, engineers, and collaborators is dedicated to advancing fatigue research.</p> <ul> <li> <p> Dr Jan Papuga <p>Action Chair &amp; Grant Holder Scientific Representative</p> <p> Contact  Contact 2</p> <li> <p> Prof Charalampos Baniotopoulos <p>Action Vice-Chair  </p> <p> Contact  Contact 2</p>"},{"location":"license/","title":"License","text":"<p>MIT License Copyright (c) 2025 FABER WG6</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <ol> <li> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> </li> <li> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> </li> </ol>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#fatpy","title":"<code>fatpy</code>","text":"<p>FatPy - A Python package for fatigue life evaluation of materials.</p>"},{"location":"api/#fatpy.core","title":"<code>core</code>","text":"<p>Core fatigue analysis methods and functionality.</p>"},{"location":"api/#fatpy.core.damage_cumulation","title":"<code>damage_cumulation</code>","text":"<p>Damage cumulation module.</p> <p>The module implements various fatigue damage accumulation rules used to estimate the total damage under variable amplitude loading. They include both classical linear models, such as Palmgren\u2013Miner\u2019s rule, and more advanced non-linear approaches that account for load sequence effects, mean stress influence, and material-specific behavior for improved fatigue life prediction.</p>"},{"location":"api/#fatpy.core.decompositions","title":"<code>decompositions</code>","text":"<p>Decompositions module.</p> <p>Methods for breaking down complex load signals to cycles. Contains both the uniaxial and the multiaxial procedures.</p>"},{"location":"api/#fatpy.core.decompositions.multiaxial","title":"<code>multiaxial</code>","text":"<p>Multiaxial decompositions methods.</p> <p>These routines provide tools for decomposing multiaxial stress and strain states into their individual components, such as normal and shear parts, principal values, and others. They are essential for analyzing complex loading conditions, enabling accurate evaluation of material behavior under multiaxial fatigue.</p>"},{"location":"api/#fatpy.core.decompositions.multiaxial.load_path_analysis_5d","title":"<code>load_path_analysis_5d</code>","text":"<p>Load Path Analysis 5D methods of multiaxial decompositions.</p> <p>These methods compute the amplitude (J_2,a) and mean (J_2,m) values of the second invariant of the deviatoric stress tensor in five-dimensional deviatoric space. This evaluation is particularly useful in advanced multiaxial fatigue models, where accurate representation of cyclic loading paths and stress states in the deviatoric space is critical for predicting material response.</p>"},{"location":"api/#fatpy.core.decompositions.multiaxial.shear_path_analysis_2d","title":"<code>shear_path_analysis_2d</code>","text":"<p>Shear Path Analysis 2D methods of multiaxial decompositions.</p> <p>These methods are designed to evaluate the mean shear stress and shear stress amplitude acting on a specified material plane, typically used in multiaxial fatigue analysis. By projecting the stress tensor onto the plane of interest, they provide key parameters for assessing crack initiation risks and fatigue life under complex loading paths.</p>"},{"location":"api/#fatpy.core.decompositions.uniaxial","title":"<code>uniaxial</code>","text":"<p>Uniaxial decompositions methods.</p> <p>Implements algorithms designed to decompose one-dimensional signals into individual load cycles, enabling detailed analysis of variable amplitude loading. By identifying turning points and extracting cycles based on established criteria (e.g., rainflow counting), they facilitate fatigue analysis, damage assessment, and other time-domain signal evaluations.</p>"},{"location":"api/#fatpy.core.energy_life","title":"<code>energy_life</code>","text":"<p>Energy-based fatigue life analysis methods.</p> <p>Fatigue analysis methods based on the relationship between the strain energy (usually strain energy density) and number of cycles to failure.</p>"},{"location":"api/#fatpy.core.energy_life.base_methods","title":"<code>base_methods</code>","text":"<p>Base methods for the energy-life.</p>"},{"location":"api/#fatpy.core.energy_life.correction_methods","title":"<code>correction_methods</code>","text":"<p>Correction methods for the energy-life approach.</p>"},{"location":"api/#fatpy.core.energy_life.decompositions","title":"<code>decompositions</code>","text":"<p>Decomposition methods for the energy-life.</p>"},{"location":"api/#fatpy.core.energy_life.demage_parameters","title":"<code>demage_parameters</code>","text":"<p>Damage parameters calculation methods for the energy-life.</p>"},{"location":"api/#fatpy.core.plane_based_methods","title":"<code>plane_based_methods</code>","text":"<p>Plane-based methods module.</p> <p>Methods for processing stress tensor path on a material plane. Provides basic infrastructure for prediction methods based on critical-plane and integral approaches.</p>"},{"location":"api/#fatpy.core.plane_based_methods.plane_search","title":"<code>plane_search</code>","text":"<p>Plane Search methods.</p> <p>Algorithms to identify a subset of potentially critical planes for further detailed analysis and processing by critical-plane and integral methods.</p>"},{"location":"api/#fatpy.core.strain_life","title":"<code>strain_life</code>","text":"<p>Strain-based fatigue life analysis methods.</p> <p>These methods perform fatigue analysis using the relationship between strain amplitude and the number of cycles to failure, as expressed by strain-life (\u03b5-N) approaches such as the Coffin-Manson and Basquin laws. They are particularly suited for low-cycle and transitional fatigue regimes, where plastic strain plays a significant role, enabling life prediction under variable amplitude or multiaxial loading when combined with appropriate mean stress corrections and cycle counting techniques.</p>"},{"location":"api/#fatpy.core.strain_life.base_methods","title":"<code>base_methods</code>","text":"<p>Base methods for the strain-life.</p>"},{"location":"api/#fatpy.core.strain_life.correction_methods","title":"<code>correction_methods</code>","text":"<p>Correction methods for the strain-life approach.</p> <p>Methods to estimate notch stress/strain with local yielding and apply mean stress correction.</p>"},{"location":"api/#fatpy.core.strain_life.correction_methods.elastic_plastic_conversion","title":"<code>elastic_plastic_conversion</code>","text":"<p>Elastic-Plastic Conversion methods for Strain-Life analysis.</p> <p>These methods convert purely elastic stress or strain states into their elastic-plastic equivalents to account for local yielding effects in fatigue or fracture assessments. Using approaches such as Neuber's rule or Glinka's strain energy density method, they provide corrected stress-strain values that better represent actual material behavior under high local stresses, especially at notches or other stress concentrators.</p>"},{"location":"api/#fatpy.core.strain_life.correction_methods.mean_stress_effect","title":"<code>mean_stress_effect</code>","text":"<p>Mean Stress Effect correction methods for Strain-Life Analysis.</p> <p>The methods for incorporating the effect of mean stress in strain-life (\u03b5-N) analysis.</p>"},{"location":"api/#fatpy.core.strain_life.damage_params","title":"<code>damage_params</code>","text":"<p>Damage parameters calculation methods for the strain-life approach.</p> <p>This module includes both uniaxial and multiaxial parameters for low-cycle fatigue assessment, covering a range of strain-life-based damage models suitable for high plastic strain regimes. It also incorporates methods based on the FKM Guideline, enabling standardized evaluation of fatigue strength under complex loading conditions.</p>"},{"location":"api/#fatpy.core.strain_life.damage_params.fkm_nonlin","title":"<code>fkm_nonlin</code>","text":"<p>fkm non-linear damage parameter calculations for strain-life analysis.</p> <p>The module contains damage parameters based on FKM-Guideline Non-Linear.</p>"},{"location":"api/#fatpy.core.strain_life.damage_params.multiaxial","title":"<code>multiaxial</code>","text":"<p>Multiaxial fatigue criteria methods for the strain-life approach.</p> <p>These methods perform low-cycle fatigue assessment using multiaxial damage parameters that combine stress, strain, and mean stress effects into a single fatigue-relevant quantity. By incorporating critical plane, invariant-based, and energy-based criteria, they enable life prediction for components subjected to complex non-proportional loading paths where significant plastic deformation occurs.</p>"},{"location":"api/#fatpy.core.strain_life.damage_params.uniaxial","title":"<code>uniaxial</code>","text":"<p>Uniaxial fatigue criteria methods for the strain-life approach.</p> <p>These methods compute uniaxial damage parameters used in strain-life (\u03b5-N) analysis to correlate cyclic strain amplitudes with fatigue life. They include parameters such as Coffin-Manson, Morrow, and Smith-Watson-Topper (SWT), which combine elastic and plastic strain components\u2014and, when applicable, mean stress effects\u2014into a single scalar value for life prediction under uniaxial loading conditions.</p>"},{"location":"api/#fatpy.core.stress_life","title":"<code>stress_life</code>","text":"<p>Stress-based fatigue life analysis methods.</p> <p>Stress-based fatigue assessment methods. Contains approach to estimate fatigue damage and their correction on various fatigue effects (stress concentration, size, surface quality, etc.)</p>"},{"location":"api/#fatpy.core.stress_life.base_methods","title":"<code>base_methods</code>","text":"<p>Base methods for the stress-life.</p>"},{"location":"api/#fatpy.core.stress_life.correction_methods","title":"<code>correction_methods</code>","text":"<p>Correction methods for the stress-life.</p> <p>These methods project how various factors\u2014such as surface finish, size effect, mean stress, residual stresses, temperature, manufacturing defects, and notch geometry\u2014modify the fatigue strength of a real component by quantifying shifts in the S-N curve or fatigue limit.</p>"},{"location":"api/#fatpy.core.stress_life.correction_methods.eq_stress_at_crit_dist","title":"<code>eq_stress_at_crit_dist</code>","text":"<p>Equivalent stress at critical distance correction methods for stress-life approach.</p> <p>These modules implement various Theory of Critical Distances (TCD)-based approaches for stress-gradient correction, which improve fatigue strength predictions near stress concentrators such as notches or cracks. By incorporating characteristic length parameters, the methods account for the spatial distribution of stress and mitigate the over-conservatism of local stress-based criteria, offering more accurate fatigue assessments under both uniaxial and multiaxial loading conditions.</p>"},{"location":"api/#fatpy.core.stress_life.correction_methods.fatigue_limit","title":"<code>fatigue_limit</code>","text":"<p>Fatigue limit correction methods for the stress-life approach.</p> <p>These routines calculate correction factors that modify the fatigue limit in an S-N curve to account for real-world influences such as surface finish, size effect, mean stress, residual stresses, temperature, and notches. By combining these empirical correction models, adjusted endurance limits may be produced for component-level fatigue prediction.</p>"},{"location":"api/#fatpy.core.stress_life.correction_methods.power_law","title":"<code>power_law</code>","text":"<p>Power law correction methods for the stress-life approach.</p> <p>These methods are used to project the influence of various factors\u2014such as surface finish, size effect, mean stress, or residual stresses\u2014on the slope of the S-N curve for a real component. The fatigue behavior is modeled using a power law formulation.</p>"},{"location":"api/#fatpy.core.stress_life.damage_params","title":"<code>damage_params</code>","text":"<p>Damage parameters calculation methods for the stress-life approach.</p> <p>These methods provide parameters for evaluating stress-based fatigue damage under uniaxial or multiaxial loading conditions. They include critical plane and invariant-based approaches, such as maximum principal stress, Findley's and Dang Van's criteria, which relate the applied stress state to fatigue life by identifying the most damaging stress components or orientations.</p>"},{"location":"api/#fatpy.core.stress_life.damage_params.multiaxial","title":"<code>multiaxial</code>","text":"<p>Multiaxial fatigue criteria methods for the stress-life approach.</p> <p>These modules implement a range of criteria for assessing fatigue strength under multiaxial stress states, addressing both proportional and non-proportional loading paths. The implemented models include critical plane approaches, energy-based methods, and stress invariants, enabling prediction of fatigue limits/strengths for complex loading scenarios across various materials and geometries.</p>"},{"location":"api/#fatpy.core.stress_life.damage_params.uniaxial","title":"<code>uniaxial</code>","text":"<p>Uniaxial fatigue criteria methods for the stress-life approach.</p> <p>Contains criteria that address uniaxial high-cycle fatigue by incorporating the mean stress effect through an equivalent stress amplitude approach. By adjusting the stress amplitude to account for mean stress influences\u2014using models such as Goodman, Gerber, or Soderberg\u2014they enable more accurate fatigue life predictions where mean stresses significantly affect material endurance.</p>"},{"location":"api/#fatpy.data_parsing","title":"<code>data_parsing</code>","text":"<p>Data parsing utilities for the fatigue analysis package.</p>"},{"location":"api/#fatpy.data_parsing.fe_model","title":"<code>fe_model</code>","text":"<p>Finite element model parsing module.</p>"},{"location":"api/#fatpy.data_parsing.loads","title":"<code>loads</code>","text":"<p>Load data parsing module.</p>"},{"location":"api/#fatpy.data_parsing.material","title":"<code>material</code>","text":"<p>Material properties parsing module.</p>"},{"location":"api/#fatpy.data_parsing.user_input","title":"<code>user_input</code>","text":"<p>User input data parsing module.</p>"},{"location":"api/#fatpy.examples","title":"<code>examples</code>","text":"<p>This module contains an example function with a detailed docstring.</p>"},{"location":"api/#fatpy.examples.docstring_example_tmp","title":"<code>docstring_example_tmp</code>","text":"<p>This module contains an example function with a detailed docstring.</p>"},{"location":"api/#fatpy.examples.docstring_example_tmp.ExampleClass","title":"<code>ExampleClass</code>","text":"<p>An example class to demonstrate docstring formatting.</p> Source code in <code>src/fatpy/examples/docstring_example_tmp.py</code> <pre><code>class ExampleClass:\n    \"\"\"An example class to demonstrate docstring formatting.\"\"\"\n\n    def __init__(self, value: int):\n        \"\"\"Initialize the ExampleClass with a value.\n\n        Args:\n            value (int): The initial value for the class instance.\n        \"\"\"\n        self.value = value\n\n    def increment(self, amount: int) -&gt; int:\n        \"\"\"Increment the stored value by a specified amount.\n\n        Args:\n            amount (int): The amount to increment the value by.\n\n        Returns:\n            int: The new value after incrementing.\n        \"\"\"\n        self.value += amount\n        return self.value\n\n    def example_method_with_docstring(self, a: int, b: int) -&gt; int:\n        # ruff: noqa: E501\n        \"\"\"Docstring with a cross-reference to the example function.\n\n        This method demonstrates how to reference another function's docstring.\n        It calls `example_function_with_docstring` with sample arguments.\n\n        Cross-reference:\n            1. [fatpy.examples.docstring_example_tmp.example_function_with_docstring][]\n            2. [`Reference with title`][fatpy.examples.docstring_example_tmp.example_function_with_docstring]\n\n        Args:\n            a (int): The first integer value.\n            b (int): The second integer value.\n\n        Returns:\n            int: The result of the example function.\n        \"\"\"\n        return example_function_with_docstring(a, b)\n</code></pre>"},{"location":"api/#fatpy.examples.docstring_example_tmp.ExampleClass.__init__","title":"<code>__init__(value)</code>","text":"<p>Initialize the ExampleClass with a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The initial value for the class instance.</p> required Source code in <code>src/fatpy/examples/docstring_example_tmp.py</code> <pre><code>def __init__(self, value: int):\n    \"\"\"Initialize the ExampleClass with a value.\n\n    Args:\n        value (int): The initial value for the class instance.\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"api/#fatpy.examples.docstring_example_tmp.ExampleClass.increment","title":"<code>increment(amount)</code>","text":"<p>Increment the stored value by a specified amount.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>The amount to increment the value by.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The new value after incrementing.</p> Source code in <code>src/fatpy/examples/docstring_example_tmp.py</code> <pre><code>def increment(self, amount: int) -&gt; int:\n    \"\"\"Increment the stored value by a specified amount.\n\n    Args:\n        amount (int): The amount to increment the value by.\n\n    Returns:\n        int: The new value after incrementing.\n    \"\"\"\n    self.value += amount\n    return self.value\n</code></pre>"},{"location":"api/#fatpy.examples.docstring_example_tmp.ExampleClass.example_method_with_docstring","title":"<code>example_method_with_docstring(a, b)</code>","text":"<p>Docstring with a cross-reference to the example function.</p> <p>This method demonstrates how to reference another function's docstring. It calls <code>example_function_with_docstring</code> with sample arguments.</p> Cross-reference <ol> <li>fatpy.examples.docstring_example_tmp.example_function_with_docstring</li> <li><code>Reference with title</code></li> </ol> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>The first integer value.</p> required <code>b</code> <code>int</code> <p>The second integer value.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The result of the example function.</p> Source code in <code>src/fatpy/examples/docstring_example_tmp.py</code> <pre><code>def example_method_with_docstring(self, a: int, b: int) -&gt; int:\n    # ruff: noqa: E501\n    \"\"\"Docstring with a cross-reference to the example function.\n\n    This method demonstrates how to reference another function's docstring.\n    It calls `example_function_with_docstring` with sample arguments.\n\n    Cross-reference:\n        1. [fatpy.examples.docstring_example_tmp.example_function_with_docstring][]\n        2. [`Reference with title`][fatpy.examples.docstring_example_tmp.example_function_with_docstring]\n\n    Args:\n        a (int): The first integer value.\n        b (int): The second integer value.\n\n    Returns:\n        int: The result of the example function.\n    \"\"\"\n    return example_function_with_docstring(a, b)\n</code></pre>"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring","title":"<code>example_function_with_docstring(a, b)</code>","text":"<p>This docstring highlights Mermaid diagrams, math expressions, and code examples.</p> <p>This function takes two integers and returns their sum. It demonstrates various mkdocs-material features:</p> <p>Information</p> <p>This is an informational admonition block.</p> <p>Important Note</p> <p>Make sure both parameters are integers.</p>"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring--mermaid-diagram","title":"Mermaid Diagram","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Is it a number?}\n    B -- Yes --&gt; C[Process the number]\n    B -- No --&gt; D[Throw an error]\n    C --&gt; E[End]\n    D --&gt; E</code></pre>"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring--mathematical-expression","title":"Mathematical Expression","text":"\\[ \\varphi = \\frac{1 + \\sqrt{5}}{2} \\] <p>Inline math: \\(E = mc^2\\)</p>"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring--code-examples","title":"Code Examples","text":"PythonJavaScript <pre><code>def add(a: int, b: int) -&gt; int:\n    return a + b\n</code></pre> <pre><code>function add(a, b) {\n    return a + b;\n}\n</code></pre> Expandable Example <p>This is a collapsible content section that shows more detailed usage:</p> <pre><code>result = example_function_with_docstring(5, 3)\nprint(f\"Result: {result}\")  # Output: Result: 8\n</code></pre>"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring--table-example","title":"Table Example","text":"Input A Input B Result 1 2 3 5 7 12 0 0 0"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring--args","title":"Args:","text":"<ul> <li><code>a</code> (int): The first integer.</li> <li><code>b</code> (int): The second integer.</li> </ul>"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring--returns","title":"Returns:","text":"<ul> <li>int: The sum of the two integers.</li> </ul>"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring--raises","title":"Raises:","text":"<ul> <li><code>TypeError</code>: If inputs are not integers.</li> </ul>"},{"location":"api/#fatpy.examples.docstring_example_tmp.example_function_with_docstring--examples","title":"Examples:","text":"<pre><code>&gt;&gt;&gt; example_function_with_docstring(2, 3)\n5\n&gt;&gt;&gt; example_function_with_docstring(0, 0)\n0\n</code></pre> Source code in <code>src/fatpy/examples/docstring_example_tmp.py</code> <pre><code>def example_function_with_docstring(a: int, b: int) -&gt; int:\n    r\"\"\"This docstring highlights Mermaid diagrams, math expressions, and code examples.\n\n    This function takes two integers and returns their sum.\n    It demonstrates various mkdocs-material features:\n\n    !!! info \"Information\"\n        This is an informational admonition block.\n\n    !!! warning \"Important Note\"\n        Make sure both parameters are integers.\n\n    ### Mermaid Diagram\n    ```mermaid\n    graph TD\n        A[Start] --&gt; B{Is it a number?}\n        B -- Yes --&gt; C[Process the number]\n        B -- No --&gt; D[Throw an error]\n        C --&gt; E[End]\n        D --&gt; E\n    ```\n\n    ### Mathematical Expression\n    $$ \\varphi = \\frac{1 + \\sqrt{5}}{2} $$\n\n    Inline math: $E = mc^2$\n\n    ### Code Examples\n    === \"Python\"\n        ```python\n        def add(a: int, b: int) -&gt; int:\n            return a + b\n        ```\n\n    === \"JavaScript\"\n        ```javascript\n        function add(a, b) {\n            return a + b;\n        }\n        ```\n\n    ??? example \"Expandable Example\"\n        This is a collapsible content section that shows more detailed usage:\n\n        ```python\n        result = example_function_with_docstring(5, 3)\n        print(f\"Result: {result}\")  # Output: Result: 8\n        ```\n\n    ### Table Example\n    | Input A | Input B | Result |\n    |---------|---------|--------|\n    | 1       | 2       | 3      |\n    | 5       | 7       | 12     |\n    | 0       | 0       | 0      |\n\n    #### Args:\n    - `a` (*int*): The first integer.\n    - `b` (*int*): The second integer.\n\n    #### Returns:\n    - *int*: The sum of the two integers.\n\n    #### Raises:\n    - `TypeError`: If inputs are not integers.\n\n    #### Examples:\n    ```python\n    &gt;&gt;&gt; example_function_with_docstring(2, 3)\n    5\n    &gt;&gt;&gt; example_function_with_docstring(0, 0)\n    0\n    ```\n    \"\"\"\n    return a + b\n</code></pre>"},{"location":"api/#fatpy.material_laws","title":"<code>material_laws</code>","text":"<p>Material laws module.</p> <p>Contains classes and functions that define material laws and enable their calibration for the material under consideration.</p>"},{"location":"api/#fatpy.material_laws.cyclic_stress_strain_curve","title":"<code>cyclic_stress_strain_curve</code>","text":"<p>Cyclic stress\u2013strain curve approximation models.</p> <p>Implements various formulations, such as the Ramberg\u2013Osgood model, describing the relationship between elastic\u2013plastic stress and strain.</p>"},{"location":"api/#fatpy.material_laws.en_curve","title":"<code>en_curve</code>","text":"<p>Strain-life curve approximations.</p> <p>Implements strain-life (\u03b5-N) curve models such as the Manson-Coffin and Basquin relations, and provides conversions between strain amplitude and fatigue life in both directions.</p>"},{"location":"api/#fatpy.material_laws.hookes_law","title":"<code>hookes_law</code>","text":"<p>Hooke's law.</p> <p>Converts between elastic stress and strain with varying levels of complexity depending on dimensionality.</p>"},{"location":"api/#fatpy.material_laws.regression_analysis","title":"<code>regression_analysis</code>","text":"<p>Regression analysis methods of material laws.</p> <p>Implements linear and non-linear regression methods for calibrating material laws.</p>"},{"location":"api/#fatpy.material_laws.sn_curve","title":"<code>sn_curve</code>","text":"<p>Stress-life curve methods of material laws.</p> <p>Provides implementations of W\u00f6hler (S-N) curve models along with methods for converting between stress amplitude and fatigue life in both directions.</p>"},{"location":"api/#fatpy.struct_mech","title":"<code>struct_mech</code>","text":"<p>Structural mechanics module.</p> <p>Contains structural mechanics related classes and methods.</p>"},{"location":"api/#fatpy.struct_mech.strain","title":"<code>strain</code>","text":"<p>Calculate fundamental strain metrics and invariants.</p> <p>These functions provide principal strains, hydrostatic strain, von Mises equivalent strain, and invariants of the strain tensor. They are essential for strength, fatigue, and fracture analyses under both uniaxial and multiaxial loading conditions.</p> <p>Conventions: - Vectors use Voigt notation with shape (..., 6), where the last dimension   contains the six Voigt components and leading dimensions are preserved:</p> <pre><code>    (\u03b5_11, \u03b5_22, \u03b5_33, \u03b5_23, \u03b5_13, \u03b5_12)\n    (\u03b5_xx, \u03b5_yy, \u03b5_zz, \u03b5_yz, \u03b5_xz, \u03b5_xy)\n</code></pre> <ul> <li>Principal strains are ordered in descending order throughout the module:     \u03b51 \u2265 \u03b52 \u2265 \u03b53.</li> <li>Principal directions (eigenvectors) are aligned to this ordering     (columns correspond to \u03b51, \u03b52, \u03b53).</li> </ul>"},{"location":"api/#fatpy.struct_mech.strain.calc_principal_strains_and_directions","title":"<code>calc_principal_strains_and_directions(strain_vector_voigt)</code>","text":"<p>Calculate principal strains and principal directions for each state.</p> Math Equations <p>Principal strains and directions are found by solving the eigenvalue problem for the strain tensor:</p> \\[ \\varepsilon \\mathbf{v} = \\lambda \\mathbf{v} \\] <p>Parameters:</p> Name Type Description Default <code>strain_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt strain components. Leading dimensions are preserved.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <code>(eigvals, eigvecs)</code> <ul> <li>eigvals: Array of shape (..., 3). Principal strains (descending: \u03b5_1 \u2265 \u03b5_2 \u2265 \u03b5_3) with leading dimensions preserved.</li> <li>eigvecs: Array of shape (..., 3, 3). Principal directions (columns are eigenvectors) aligned with eigvals in the same order. The last two dimensions are the 3x3 eigenvector matrix for each input.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/strain.py</code> <pre><code>def calc_principal_strains_and_directions(\n    strain_vector_voigt: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    r\"\"\"Calculate principal strains and principal directions for each state.\n\n    ??? abstract \"Math Equations\"\n        Principal strains and directions are found by solving the eigenvalue problem\n        for the strain tensor:\n\n        $$ \\varepsilon \\mathbf{v} = \\lambda \\mathbf{v} $$\n\n    Args:\n        strain_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt strain components. Leading dimensions are preserved.\n\n    Returns:\n        Tuple (eigvals, eigvecs):\n            - eigvals: Array of shape (..., 3). Principal strains\n            (descending: \u03b5_1 \u2265 \u03b5_2 \u2265 \u03b5_3) with leading dimensions preserved.\n            - eigvecs: Array of shape (..., 3, 3). Principal directions (columns are\n            eigenvectors) aligned with eigvals in the same order. The last two\n            dimensions are the 3x3 eigenvector matrix for each input.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(strain_vector_voigt)\n\n    tensor = voigt.voigt_to_tensor(strain_vector_voigt)\n    eigvals, eigvecs = np.linalg.eigh(tensor)\n    sorted_indices = np.argsort(eigvals, axis=-1)[..., ::-1]\n    eigvals_sorted = np.take_along_axis(eigvals, sorted_indices, axis=-1)\n    eigvecs_sorted = np.take_along_axis(\n        eigvecs, np.expand_dims(sorted_indices, axis=-2), axis=-1\n    )\n\n    return eigvals_sorted, eigvecs_sorted\n</code></pre>"},{"location":"api/#fatpy.struct_mech.strain.calc_principal_strains","title":"<code>calc_principal_strains(strain_vector_voigt)</code>","text":"<p>Calculate principal strains for each strain state.</p> Math Equations <p>Principal strains are found by solving the eigenvalue problem for the strain tensor:</p> \\[ \\varepsilon \\mathbf{v} = \\lambda \\mathbf{v} \\] <p>Parameters:</p> Name Type Description Default <code>strain_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt strain components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (..., 3). Principal strains (descending: \u03b51 \u2265 \u03b52 \u2265 \u03b53).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/strain.py</code> <pre><code>def calc_principal_strains(\n    strain_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate principal strains for each strain state.\n\n    ??? abstract \"Math Equations\"\n        Principal strains are found by solving the eigenvalue problem\n        for the strain tensor:\n\n        $$ \\varepsilon \\mathbf{v} = \\lambda \\mathbf{v} $$\n\n    Args:\n        strain_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt strain components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (..., 3). Principal strains (descending: \u03b51 \u2265 \u03b52 \u2265 \u03b53).\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(strain_vector_voigt)\n\n    tensor = voigt.voigt_to_tensor(strain_vector_voigt)\n    eigvals = np.linalg.eigvalsh(tensor)\n\n    return np.sort(eigvals, axis=-1)[..., ::-1]\n</code></pre>"},{"location":"api/#fatpy.struct_mech.strain.calc_strain_invariants","title":"<code>calc_strain_invariants(strain_vector_voigt)</code>","text":"<p>Calculate the first, second, and third invariants for each strain state.</p> Math Equations \\[ \\begin{align*} I_1 &amp;=  tr(\\varepsilon), \\\\ I_2 &amp;= \\tfrac{1}{2}\\big(I_1^{2} - tr(\\varepsilon^{2})\\big), \\\\ I_3 &amp;= \\det(\\varepsilon) \\end{align*} \\] <p>Parameters:</p> Name Type Description Default <code>strain_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt strain components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (..., 3). The last dimension contains (I1, I2, I3) for each entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/strain.py</code> <pre><code>def calc_strain_invariants(\n    strain_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate the first, second, and third invariants for each strain state.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\begin{align*}\n        I_1 &amp;=  tr(\\varepsilon), \\\\\n        I_2 &amp;= \\tfrac{1}{2}\\big(I_1^{2} - tr(\\varepsilon^{2})\\big), \\\\\n        I_3 &amp;= \\det(\\varepsilon)\n        \\end{align*}\n        $$\n\n    Args:\n        strain_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt strain components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (..., 3). The last dimension contains (I1, I2, I3) for\n            each entry.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(strain_vector_voigt)\n\n    tensor = voigt.voigt_to_tensor(strain_vector_voigt)\n    invariant_1 = np.trace(tensor, axis1=-2, axis2=-1)\n    invariant_2 = 0.5 * (\n        invariant_1**2 - np.trace(np.matmul(tensor, tensor), axis1=-2, axis2=-1)\n    )\n    invariant_3 = np.linalg.det(tensor)\n\n    return np.stack((invariant_1, invariant_2, invariant_3), axis=-1)\n</code></pre>"},{"location":"api/#fatpy.struct_mech.strain.calc_volumetric_strain","title":"<code>calc_volumetric_strain(strain_vector_voigt)</code>","text":"<p>Calculate the volumetric (mean normal)strain for each strain state.</p> Math Equations \\[ \\varepsilon_{vol} = \\frac{1}{3} \\, tr(\\varepsilon) =    \\frac{1}{3}(\\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}) \\] <p>Parameters:</p> Name Type Description Default <code>strain_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt strain components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Volumetric (mean normal) strain for each input state. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/strain.py</code> <pre><code>def calc_volumetric_strain(\n    strain_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate the volumetric (mean normal)strain for each strain state.\n\n    ??? abstract \"Math Equations\"\n        $$ \\varepsilon_{vol} = \\frac{1}{3} \\, tr(\\varepsilon) =\n           \\frac{1}{3}(\\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33})\n        $$\n\n    Args:\n        strain_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt strain components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (...). Volumetric (mean normal) strain for each input state.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(strain_vector_voigt)\n\n    return (\n        strain_vector_voigt[..., 0]\n        + strain_vector_voigt[..., 1]\n        + strain_vector_voigt[..., 2]\n    ) / 3.0\n</code></pre>"},{"location":"api/#fatpy.struct_mech.strain.calc_deviatoric_strain","title":"<code>calc_deviatoric_strain(strain_vector_voigt)</code>","text":"<p>Calculate the deviatoric strain for each strain state.</p> Math Equations <p>The strain tensor decomposes as:</p> \\[ \\varepsilon = \\varepsilon_{dev} + \\varepsilon_{vol} \\mathbf{I} \\] <p>where the deviatoric part is traceless and obtained by subtracting the volumetric part from the normal components.</p> \\[ \\varepsilon_{dev} = \\varepsilon - \\frac{1}{3} tr(\\varepsilon) \\] <p>Parameters:</p> Name Type Description Default <code>strain_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt strain components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (..., 6). Deviatoric strain for each input state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/strain.py</code> <pre><code>def calc_deviatoric_strain(\n    strain_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate the deviatoric strain for each strain state.\n\n    ??? abstract \"Math Equations\"\n        The strain tensor decomposes as:\n\n        $$ \\varepsilon = \\varepsilon_{dev} + \\varepsilon_{vol} \\mathbf{I} $$\n\n        where the deviatoric part is traceless and obtained by subtracting the\n        volumetric part from the normal components.\n\n        $$ \\varepsilon_{dev} = \\varepsilon - \\frac{1}{3} tr(\\varepsilon) $$\n\n    Args:\n        strain_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt strain components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (..., 6). Deviatoric strain for each input state.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(strain_vector_voigt)\n\n    volumetric = calc_volumetric_strain(strain_vector_voigt)\n    deviatoric = strain_vector_voigt.copy()\n    deviatoric[..., :3] = deviatoric[..., :3] - volumetric[..., None]\n\n    return deviatoric\n</code></pre>"},{"location":"api/#fatpy.struct_mech.strain.calc_von_mises_strain","title":"<code>calc_von_mises_strain(strain_vector_voigt)</code>","text":"<p>Von Mises equivalent strain computed directly from Voigt components.</p> Math Equations \\[ \\varepsilon_{vM} = \\tfrac{\\sqrt{2}}{3}\\sqrt{ (\\varepsilon_{11}-\\varepsilon_{22})^2 +(\\varepsilon_{22}-\\varepsilon_{33})^2 +(\\varepsilon_{33}-\\varepsilon_{11})^2 + 6(\\varepsilon_{12}^2+\\varepsilon_{23}^2+\\varepsilon_{13}^2)} \\] <p>Parameters:</p> Name Type Description Default <code>strain_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt strain components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Von Mises equivalent strain for each entry. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/strain.py</code> <pre><code>def calc_von_mises_strain(\n    strain_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Von Mises equivalent strain computed directly from Voigt components.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\varepsilon_{vM} = \\tfrac{\\sqrt{2}}{3}\\sqrt{\n        (\\varepsilon_{11}-\\varepsilon_{22})^2\n        +(\\varepsilon_{22}-\\varepsilon_{33})^2\n        +(\\varepsilon_{33}-\\varepsilon_{11})^2\n        + 6(\\varepsilon_{12}^2+\\varepsilon_{23}^2+\\varepsilon_{13}^2)}\n        $$\n\n    Args:\n        strain_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt strain components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (...). Von Mises equivalent strain for each entry.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(strain_vector_voigt)\n\n    e11 = strain_vector_voigt[..., 0]\n    e22 = strain_vector_voigt[..., 1]\n    e33 = strain_vector_voigt[..., 2]\n    e23 = strain_vector_voigt[..., 3]  # epsilon_23\n    e13 = strain_vector_voigt[..., 4]  # epsilon_13\n    e12 = strain_vector_voigt[..., 5]  # epsilon_12\n    return np.sqrt(\n        (2.0 / 9.0)\n        * (\n            (e11 - e22) ** 2\n            + (e22 - e33) ** 2\n            + (e33 - e11) ** 2\n            + 6.0 * (e12**2 + e23**2 + e13**2)\n        )\n    )\n</code></pre>"},{"location":"api/#fatpy.struct_mech.strain.calc_signed_von_mises_by_max_abs_principal","title":"<code>calc_signed_von_mises_by_max_abs_principal(strain_vector_voigt, rtol=1e-05, atol=1e-08)</code>","text":"<p>Calculate signed von Mises equivalent strain for each strain state.</p> <p>Sign is determined by average of the maximum and minimum principal strains.</p> Sign Convention <p>The sign assignment follows these rules:</p> <ul> <li>Positive (+): When (\u03b5\u2081 + \u03b5\u2083)/2 &gt; 0 (tension dominant)</li> <li>Negative (-): When (\u03b5\u2081 + \u03b5\u2083)/2 &lt; 0 (compression dominant)</li> <li>Positive (+): When (\u03b5\u2081 + \u03b5\u2083)/2 \u2248 0 (within tolerance, default fallback)</li> </ul> <p>Tolerance parameters ensure numerical stability in edge cases where the determining value is very close to zero, preventing erratic sign changes that could occur due to floating-point precision limitations.</p> Math Equations \\[ \\varepsilon_{SvM} = \\begin{cases} +\\varepsilon_{vM} &amp; \\text{if } \\frac{\\varepsilon_1 + \\varepsilon_3}{2} \\geq 0 \\\\ -\\varepsilon_{vM} &amp; \\text{if } \\frac{\\varepsilon_1 + \\varepsilon_3}{2} &lt; 0 \\end{cases} \\] <p>Parameters:</p> Name Type Description Default <code>strain_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt strain components. Leading dimensions are preserved.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for comparing the average of maximum and minimum principal strain to zero. Default is 1e-5.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for comparing the average of maximum and minimum principal strain to zero. Default is 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Signed von Mises equivalent strain for each entry. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/strain.py</code> <pre><code>def calc_signed_von_mises_by_max_abs_principal(\n    strain_vector_voigt: NDArray[np.float64],\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate signed von Mises equivalent strain for each strain state.\n\n    Sign is determined by average of the maximum and minimum principal strains.\n\n    ??? note \"Sign Convention\"\n        The sign assignment follows these rules:\n\n        - **Positive (+)**: When (\u03b5\u2081 + \u03b5\u2083)/2 &gt; 0 (tension dominant)\n        - **Negative (-)**: When (\u03b5\u2081 + \u03b5\u2083)/2 &lt; 0 (compression dominant)\n        - **Positive (+)**: When (\u03b5\u2081 + \u03b5\u2083)/2 \u2248 0 (within tolerance, default fallback)\n\n    Tolerance parameters ensure numerical stability in edge cases where the\n    determining value is very close to zero, preventing erratic sign changes\n    that could occur due to floating-point precision limitations.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\varepsilon_{SvM} = \\begin{cases}\n        +\\varepsilon_{vM} &amp; \\text{if } \\frac{\\varepsilon_1 + \\varepsilon_3}{2} \\geq 0 \\\\\n        -\\varepsilon_{vM} &amp; \\text{if } \\frac{\\varepsilon_1 + \\varepsilon_3}{2} &lt; 0\n        \\end{cases}\n        $$\n\n    Args:\n        strain_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt strain components. Leading dimensions are preserved.\n        rtol: Relative tolerance for comparing the average of maximum and minimum\n            principal strain to zero. Default is 1e-5.\n        atol: Absolute tolerance for comparing the average of maximum and minimum\n            principal strain to zero. Default is 1e-8.\n\n    Returns:\n        Array of shape (...). Signed von Mises equivalent strain for each entry.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(strain_vector_voigt)\n\n    von_mises = calc_von_mises_strain(strain_vector_voigt)\n    principals = calc_principal_strains(strain_vector_voigt)\n\n    avg_13 = 0.5 * (principals[..., 0] + principals[..., 2])\n    sign = np.sign(avg_13).astype(np.float64, copy=False)\n    sign = np.where(np.isclose(avg_13, 0, rtol=rtol, atol=atol), 1.0, sign)\n\n    return sign * von_mises\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress","title":"<code>stress</code>","text":"<p>Calculate fundamental stress metrics and invariants.</p> <p>These functions provide principal stresses, maximum shear (Tresca) stress, hydrostatic stress, von Mises equivalent stress, and invariants of the stress tensor. They are essential for strength, fatigue, and fracture analyses under both uniaxial and multiaxial loading conditions.</p> <p>Conventions: - Vectors use Voigt notation with shape (..., 6), where the last dimension   contains the six Voigt components and leading dimensions are preserved:</p> <pre><code>    (\u03c3_11, \u03c3_22, \u03c3_33, \u03c3_23, \u03c3_13, \u03c3_12)\n    (\u03c3_xx, \u03c3_yy, \u03c3_zz, \u03c3_yz, \u03c3_xz, \u03c3_xy)\n</code></pre> <ul> <li> <p>Principal stresses are ordered in descending order throughout the module   (\u03c3_1 \u2265 \u03c3_2 \u2265 \u03c3_3).</p> </li> <li> <p>Principal directions (eigenvectors) are aligned to this ordering   (columns correspond to \u03c3_1, \u03c3_2, \u03c3_3).</p> </li> </ul>"},{"location":"api/#fatpy.struct_mech.stress.calc_principal_stresses_and_directions","title":"<code>calc_principal_stresses_and_directions(stress_vector_voigt)</code>","text":"<p>Calculate principal stresses and principal directions for each state.</p> Math Equations <p>Principal stresses and directions are found by solving the eigenvalue problem for the stress tensor:</p> \\[ \\sigma \\mathbf{v} = \\lambda \\mathbf{v} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <code>(eigvals, eigvecs)</code> <ul> <li>eigvals: Array of shape (..., 3). Principal stresses (descending: \u03c3_1 \u2265 \u03c3_2 \u2265 \u03c3_3) with leading dimensions preserved.</li> <li>eigvecs: Array of shape (..., 3, 3). Principal directions (columns are eigenvectors) aligned with eigvals in the same order. The last two dimensions are the 3x3 eigenvector matrix for each input.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_principal_stresses_and_directions(\n    stress_vector_voigt: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    r\"\"\"Calculate principal stresses and principal directions for each state.\n\n    ??? abstract \"Math Equations\"\n        Principal stresses and directions are found by solving the eigenvalue problem\n        for the stress tensor:\n\n        $$ \\sigma \\mathbf{v} = \\lambda \\mathbf{v} $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n\n    Returns:\n        Tuple (eigvals, eigvecs):\n            - eigvals: Array of shape (..., 3). Principal stresses\n            (descending: \u03c3_1 \u2265 \u03c3_2 \u2265 \u03c3_3) with leading dimensions preserved.\n            - eigvecs: Array of shape (..., 3, 3). Principal directions (columns are\n            eigenvectors) aligned with eigvals in the same order. The last two\n            dimensions are the 3x3 eigenvector matrix for each input.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(stress_vector_voigt)\n\n    tensor = voigt.voigt_to_tensor(stress_vector_voigt)\n    eigvals, eigvecs = np.linalg.eigh(tensor)\n    sorted_indices = np.argsort(eigvals, axis=-1)[..., ::-1]\n    eigvals_sorted = np.take_along_axis(eigvals, sorted_indices, axis=-1)\n    eigvecs_sorted = np.take_along_axis(\n        eigvecs, np.expand_dims(sorted_indices, axis=-2), axis=-1\n    )\n\n    return eigvals_sorted, eigvecs_sorted\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_principal_stresses","title":"<code>calc_principal_stresses(stress_vector_voigt)</code>","text":"<p>Calculate principal stresses for each stress state.</p> Math Equations <p>Principal stresses are found by solving the eigenvalue problem for the stress tensor:</p> \\[ \\sigma \\mathbf{v} = \\lambda \\mathbf{v} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (..., 3). Principal stresses (descending: \u03c31 \u2265 \u03c32 \u2265 \u03c33).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_principal_stresses(\n    stress_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate principal stresses for each stress state.\n\n    ??? abstract \"Math Equations\"\n        Principal stresses are found by solving the eigenvalue problem\n        for the stress tensor:\n\n        $$ \\sigma \\mathbf{v} = \\lambda \\mathbf{v} $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (..., 3). Principal stresses (descending: \u03c31 \u2265 \u03c32 \u2265 \u03c33).\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(stress_vector_voigt)\n\n    tensor = voigt.voigt_to_tensor(stress_vector_voigt)\n    eigvals = np.linalg.eigvalsh(tensor)\n\n    # eigvals shape: (n, ..., 3). Return sorted descending along last axis.\n    return np.sort(eigvals, axis=-1)[..., ::-1]\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_stress_invariants","title":"<code>calc_stress_invariants(stress_vector_voigt)</code>","text":"<p>Calculate the first, second, and third invariants for each stress state.</p> Math Equations \\[ \\begin{align*} I_1 &amp;=  tr(\\sigma), \\\\ I_2 &amp;= \\frac{1}{2}(I_1^{2} - tr(\\sigma^{2})), \\\\ I_3 &amp;= \\det(\\sigma) \\end{align*} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (..., 3). The last dimension contains (I1, I2, I3) for each entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_stress_invariants(\n    stress_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate the first, second, and third invariants for each stress state.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\begin{align*}\n        I_1 &amp;=  tr(\\sigma), \\\\\n        I_2 &amp;= \\frac{1}{2}(I_1^{2} - tr(\\sigma^{2})), \\\\\n        I_3 &amp;= \\det(\\sigma)\n        \\end{align*}\n        $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (..., 3). The last dimension contains (I1, I2, I3) for\n            each entry.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(stress_vector_voigt)\n\n    tensor = voigt.voigt_to_tensor(stress_vector_voigt)\n    invariant_1 = np.trace(tensor, axis1=-2, axis2=-1)\n    invariant_2 = 0.5 * (\n        invariant_1**2 - np.trace(np.matmul(tensor, tensor), axis1=-2, axis2=-1)\n    )\n    invariant_3 = np.linalg.det(tensor)\n\n    return np.stack((invariant_1, invariant_2, invariant_3), axis=-1)\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_hydrostatic_stress","title":"<code>calc_hydrostatic_stress(stress_vector_voigt)</code>","text":"<p>Calculate the hydrostatic (mean normal) stress for each stress state.</p> Math Equations \\[ \\sigma_H = \\frac{1}{3} tr(\\sigma) = \\frac{1}{3} (\\sigma_{11} + \\sigma_{22} + \\sigma_{33}) \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Hydrostatic stress for each input state. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_hydrostatic_stress(\n    stress_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate the hydrostatic (mean normal) stress for each stress state.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\sigma_H = \\frac{1}{3} tr(\\sigma) =\n        \\frac{1}{3} (\\sigma_{11} + \\sigma_{22} + \\sigma_{33})\n        $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (...). Hydrostatic stress for each input state.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(stress_vector_voigt)\n\n    # Voigt normal components are at last axis indices 0,1,2\n    return (\n        stress_vector_voigt[..., 0]\n        + stress_vector_voigt[..., 1]\n        + stress_vector_voigt[..., 2]\n    ) / 3.0\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_stress_deviator","title":"<code>calc_stress_deviator(stress_vector_voigt)</code>","text":"<p>Calculate stress deviator for each stress state.</p> Math Equations <p>The stress tensor decomposes as:</p> \\[ \\sigma = \\mathbf{s} + \\sigma_H \\mathbf{I} \\] <p>where the deviatoric part \\(\\mathbf{s}\\) is traceless and obtained by subtracting the hydrostatic part from the normal components.</p> \\[ \\mathbf{s} = \\sigma - \\frac{1}{3} tr(\\sigma) \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (..., 6). Stress deviator for each entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_stress_deviator(\n    stress_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate stress deviator for each stress state.\n\n    ??? abstract \"Math Equations\"\n        The stress tensor decomposes as:\n\n        $$ \\sigma = \\mathbf{s} + \\sigma_H \\mathbf{I} $$\n\n        where the deviatoric part $\\mathbf{s}$ is traceless and obtained by subtracting\n        the hydrostatic part from the normal components.\n\n        $$ \\mathbf{s} = \\sigma - \\frac{1}{3} tr(\\sigma) $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (..., 6). Stress deviator for each entry.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(stress_vector_voigt)\n    hydrostatic = calc_hydrostatic_stress(stress_vector_voigt)\n\n    deviator = stress_vector_voigt.copy()\n    # Subtract hydrostatic from the first three Voigt components (last axis)\n    deviator[..., :3] = deviator[..., :3] - hydrostatic[..., None]\n\n    return deviator\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_von_mises_stress","title":"<code>calc_von_mises_stress(stress_vector_voigt)</code>","text":"<p>Calculate von Mises equivalent stress for each stress state.</p> Math Equations \\[ \\sigma_{vM} = \\tfrac{\\sqrt{2}}{2}\\sqrt{ (\\sigma_{11}-\\sigma_{22})^2 +(\\sigma_{22}-\\sigma_{33})^2 +(\\sigma_{33}-\\sigma_{11})^2 + 3(\\sigma_{12}^2+\\sigma_{23}^2+\\sigma_{13}^2)} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Von Mises equivalent stress for each entry. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_von_mises_stress(\n    stress_vector_voigt: NDArray[np.float64],\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate von Mises equivalent stress for each stress state.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\sigma_{vM} = \\tfrac{\\sqrt{2}}{2}\\sqrt{\n        (\\sigma_{11}-\\sigma_{22})^2\n        +(\\sigma_{22}-\\sigma_{33})^2\n        +(\\sigma_{33}-\\sigma_{11})^2\n        + 3(\\sigma_{12}^2+\\sigma_{23}^2+\\sigma_{13}^2)}\n        $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (...). Von Mises equivalent stress for each entry.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    voigt.check_shape(stress_vector_voigt)\n\n    sx = stress_vector_voigt[..., 0]\n    sy = stress_vector_voigt[..., 1]\n    sz = stress_vector_voigt[..., 2]\n    syz = stress_vector_voigt[..., 3]\n    sxz = stress_vector_voigt[..., 4]\n    sxy = stress_vector_voigt[..., 5]\n\n    # Von Mises formula expanded to simplify computation\n    return np.sqrt(\n        0.5\n        * (\n            (sx - sy) ** 2\n            + (sy - sz) ** 2\n            + (sz - sx) ** 2\n            + 6 * (sxy**2 + syz**2 + sxz**2)\n        )\n    )\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_signed_von_mises_by_hydrostatic","title":"<code>calc_signed_von_mises_by_hydrostatic(stress_vector_voigt, rtol=1e-05, atol=1e-08)</code>","text":"<p>Calculate signed von Mises stress for each stress state.</p> <p>Sign is determined by the hydrostatic stress.</p> Sign Convention <p>The sign assignment follows these rules:</p> <ul> <li>Positive (+): When hydrostatic stress &gt; 0 (tensile dominant state)</li> <li>Negative (-): When hydrostatic stress &lt; 0 (compressive dominant state)</li> <li>Positive (+): When hydrostatic stress \u2248 0 (within tolerance, default     fallback)</li> </ul> <p>Tolerance parameters ensure numerical stability in edge cases where the determining value is very close to zero, preventing erratic sign changes that could occur due to floating-point precision limitations.</p> Math Equations \\[ \\sigma_{SvM} = \\begin{cases} +\\sigma_{vM} &amp; \\text{if } \\sigma_H \\geq 0 \\\\ -\\sigma_{vM} &amp; \\text{if } \\sigma_H &lt; 0 \\end{cases} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for comparing hydrostatic stress to zero. Default is 1e-5.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for comparing hydrostatic stress to zero. Default is 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Signed von Mises stress for each entry. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_signed_von_mises_by_hydrostatic(\n    stress_vector_voigt: NDArray[np.float64],\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate signed von Mises stress for each stress state.\n\n    Sign is determined by the hydrostatic stress.\n\n    ??? note \"Sign Convention\"\n        The sign assignment follows these rules:\n\n        - **Positive (+)**: When hydrostatic stress &gt; 0 (tensile dominant state)\n        - **Negative (-)**: When hydrostatic stress &lt; 0 (compressive dominant state)\n        - **Positive (+)**: When hydrostatic stress \u2248 0 (within tolerance, default\n            fallback)\n\n    Tolerance parameters ensure numerical stability in edge cases where the\n    determining value is very close to zero, preventing erratic sign changes\n    that could occur due to floating-point precision limitations.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\sigma_{SvM} = \\begin{cases}\n        +\\sigma_{vM} &amp; \\text{if } \\sigma_H \\geq 0 \\\\\n        -\\sigma_{vM} &amp; \\text{if } \\sigma_H &lt; 0\n        \\end{cases}\n        $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n        rtol: Relative tolerance for comparing hydrostatic stress to zero.\n            Default is 1e-5.\n        atol: Absolute tolerance for comparing hydrostatic stress to zero.\n            Default is 1e-8.\n\n    Returns:\n        Array of shape (...). Signed von Mises stress for each entry.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    von_mises = calc_von_mises_stress(stress_vector_voigt)\n    hydrostatic_stress = calc_hydrostatic_stress(stress_vector_voigt)\n\n    sign = np.sign(hydrostatic_stress).astype(np.float64, copy=False)\n    sign = np.where(np.isclose(hydrostatic_stress, 0, rtol=rtol, atol=atol), 1.0, sign)\n\n    return sign * von_mises\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_signed_von_mises_by_max_abs_principal","title":"<code>calc_signed_von_mises_by_max_abs_principal(stress_vector_voigt, rtol=1e-05, atol=1e-08)</code>","text":"<p>Calculate signed von Mises stress for each stress state.</p> <p>Sign is determined by average of the maximum and minimum principal stresses.</p> Sign Convention <p>The sign assignment follows these rules:</p> <ul> <li>Positive (+): When (\u03c3\u2081 + \u03c3\u2083)/2 &gt; 0 (tension dominant)</li> <li>Negative (-): When (\u03c3\u2081 + \u03c3\u2083)/2 &lt; 0 (compression dominant)</li> <li>Positive (+): When (\u03c3\u2081 + \u03c3\u2083)/2 \u2248 0 (within tolerance, default fallback)</li> </ul> <p>Tolerance parameters ensure numerical stability in edge cases where the determining value is very close to zero, preventing erratic sign changes that could occur due to floating-point precision limitations.</p> Math Equations \\[ \\sigma_{SvM} = \\begin{cases} +\\sigma_{vM} &amp; \\text{if } \\frac{\\sigma_1 + \\sigma_3}{2} \\geq 0 \\\\ -\\sigma_{vM} &amp; \\text{if } \\frac{\\sigma_1 + \\sigma_3}{2} &lt; 0 \\end{cases} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for comparing the average of maximum and minimum principal stresses to zero. Default is 1e-5.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for comparing the average of maximum and minimum principal stresses to zero. Default is 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Signed von Mises stress for each entry. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_signed_von_mises_by_max_abs_principal(\n    stress_vector_voigt: NDArray[np.float64],\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate signed von Mises stress for each stress state.\n\n    Sign is determined by average of the maximum and minimum principal stresses.\n\n    ??? note \"Sign Convention\"\n        The sign assignment follows these rules:\n\n        - **Positive (+)**: When (\u03c3\u2081 + \u03c3\u2083)/2 &gt; 0 (tension dominant)\n        - **Negative (-)**: When (\u03c3\u2081 + \u03c3\u2083)/2 &lt; 0 (compression dominant)\n        - **Positive (+)**: When (\u03c3\u2081 + \u03c3\u2083)/2 \u2248 0 (within tolerance, default fallback)\n\n    Tolerance parameters ensure numerical stability in edge cases where the\n    determining value is very close to zero, preventing erratic sign changes\n    that could occur due to floating-point precision limitations.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\sigma_{SvM} = \\begin{cases}\n        +\\sigma_{vM} &amp; \\text{if } \\frac{\\sigma_1 + \\sigma_3}{2} \\geq 0 \\\\\n        -\\sigma_{vM} &amp; \\text{if } \\frac{\\sigma_1 + \\sigma_3}{2} &lt; 0\n        \\end{cases}\n        $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n        rtol: Relative tolerance for comparing the average of maximum and minimum\n            principal stresses to zero. Default is 1e-5.\n        atol: Absolute tolerance for comparing the average of maximum and minimum\n            principal stresses to zero. Default is 1e-8.\n\n    Returns:\n        Array of shape (...). Signed von Mises stress for each entry.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    von_mises = calc_von_mises_stress(stress_vector_voigt)\n    principals = calc_principal_stresses(stress_vector_voigt)\n\n    avg_13 = 0.5 * (principals[..., 0] + principals[..., 2])\n    sign = np.sign(avg_13).astype(np.float64, copy=False)\n    sign = np.where(np.isclose(avg_13, 0, rtol=rtol, atol=atol), 1.0, sign)\n\n    return sign * von_mises\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_signed_von_mises_by_first_invariant","title":"<code>calc_signed_von_mises_by_first_invariant(stress_vector_voigt, rtol=1e-05, atol=1e-08)</code>","text":"<p>Calculate signed von Mises stress for each stress state.</p> <p>Sign is determined by the first invariant of the stress tensor.</p> Sign Convention <p>The sign assignment follows these rules:</p> <ul> <li>Positive (+): When tr(\u03c3) &gt; 0 (tensile volumetric stress)</li> <li>Negative (-): When tr(\u03c3) &lt; 0 (compressive volumetric stress)</li> <li>Positive (+): When tr(\u03c3) \u2248 0 (within tolerance, default fallback)</li> </ul> <p>Tolerance parameters ensure numerical stability in edge cases where the determining value is very close to zero, preventing erratic sign changes that could occur due to floating-point precision limitations.</p> Math Equations \\[ \\sigma_{SvM} = \\begin{cases} +\\sigma_{vM} &amp; \\text{if } tr(\\sigma) \\geq 0 \\\\ -\\sigma_{vM} &amp; \\text{if } tr(\\sigma) &lt; 0 \\end{cases} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for comparing the first invariant to zero. Default is 1e-5.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for comparing the first invariant to zero. Default is 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Signed von Mises stress for each entry. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_signed_von_mises_by_first_invariant(\n    stress_vector_voigt: NDArray[np.float64],\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate signed von Mises stress for each stress state.\n\n    Sign is determined by the first invariant of the stress tensor.\n\n    ??? note \"Sign Convention\"\n        The sign assignment follows these rules:\n\n        - **Positive (+)**: When tr(\u03c3) &gt; 0 (tensile volumetric stress)\n        - **Negative (-)**: When tr(\u03c3) &lt; 0 (compressive volumetric stress)\n        - **Positive (+)**: When tr(\u03c3) \u2248 0 (within tolerance, default fallback)\n\n    Tolerance parameters ensure numerical stability in edge cases where the\n    determining value is very close to zero, preventing erratic sign changes\n    that could occur due to floating-point precision limitations.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\sigma_{SvM} = \\begin{cases}\n        +\\sigma_{vM} &amp; \\text{if } tr(\\sigma) \\geq 0 \\\\\n        -\\sigma_{vM} &amp; \\text{if } tr(\\sigma) &lt; 0\n        \\end{cases}\n        $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n        rtol: Relative tolerance for comparing the first invariant to zero.\n            Default is 1e-5.\n        atol: Absolute tolerance for comparing the first invariant to zero.\n            Default is 1e-8.\n\n    Returns:\n        Array of shape (...). Signed von Mises stress for each entry.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    von_mises = calc_von_mises_stress(stress_vector_voigt)\n    invariant_1 = (\n        stress_vector_voigt[..., 0]\n        + stress_vector_voigt[..., 1]\n        + stress_vector_voigt[..., 2]\n    )\n\n    sign = np.sign(invariant_1).astype(np.float64, copy=False)\n    sign = np.where(np.isclose(invariant_1, 0, rtol=rtol, atol=atol), 1.0, sign)\n\n    return sign * von_mises\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_tresca_stress","title":"<code>calc_tresca_stress(stress_vector_voigt)</code>","text":"<p>Calculate Tresca (maximum shear) stress for each stress state.</p> Math Equations \\[\\sigma_{\\tau_{max}} = \\frac{\\sigma_{1} - \\sigma_{3}}{2}\\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Tresca stress for each entry. For principal stresses \u03c31 \u2265 \u03c32 \u2265 \u03c33, Tresca = (\u03c31 \u2212 \u03c33)/2. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_tresca_stress(stress_vector_voigt: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate Tresca (maximum shear) stress for each stress state.\n\n    ??? abstract \"Math Equations\"\n        $$\\sigma_{\\tau_{max}} = \\frac{\\sigma_{1} - \\sigma_{3}}{2}$$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n\n    Returns:\n        Array of shape (...). Tresca stress for each entry. For principal\n            stresses \u03c31 \u2265 \u03c32 \u2265 \u03c33, Tresca = (\u03c31 \u2212 \u03c33)/2.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    principals = calc_principal_stresses(stress_vector_voigt)\n    return 0.5 * (principals[..., 0] - principals[..., 2])\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_signed_tresca_by_hydrostatic","title":"<code>calc_signed_tresca_by_hydrostatic(stress_vector_voigt, rtol=1e-05, atol=1e-08)</code>","text":"<p>Calculate signed Tresca stress for each stress state.</p> <p>Sign is determined by the hydrostatic stress.</p> Sign Convention <p>The sign assignment follows these rules:</p> <ul> <li>Positive (+): When hydrostatic stress &gt; 0 (tensile dominant state)</li> <li>Negative (-): When hydrostatic stress &lt; 0 (compressive dominant state)</li> <li>Positive (+): When hydrostatic stress \u2248 0 (within tolerance, default     fallback)</li> </ul> <p>Tolerance parameters ensure numerical stability in edge cases where the determining value is very close to zero, preventing erratic sign changes that could occur due to floating-point precision limitations.</p> Math Equations \\[ \\sigma_{S\\tau_{max}} = \\begin{cases} +\\sigma_{\\tau_{max}} &amp; \\text{if } \\sigma_H \\geq 0 \\\\ -\\sigma_{\\tau_{max}} &amp; \\text{if } \\sigma_H &lt; 0 \\end{cases} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for comparing hydrostatic stress to zero. Default is 1e-5.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for comparing hydrostatic stress to zero. Default is 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Signed Tresca stress for each entry. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_signed_tresca_by_hydrostatic(\n    stress_vector_voigt: NDArray[np.float64],\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate signed Tresca stress for each stress state.\n\n    Sign is determined by the hydrostatic stress.\n\n    ??? note \"Sign Convention\"\n        The sign assignment follows these rules:\n\n        - **Positive (+)**: When hydrostatic stress &gt; 0 (tensile dominant state)\n        - **Negative (-)**: When hydrostatic stress &lt; 0 (compressive dominant state)\n        - **Positive (+)**: When hydrostatic stress \u2248 0 (within tolerance, default\n            fallback)\n\n    Tolerance parameters ensure numerical stability in edge cases where the\n    determining value is very close to zero, preventing erratic sign changes\n    that could occur due to floating-point precision limitations.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\sigma_{S\\tau_{max}} = \\begin{cases}\n        +\\sigma_{\\tau_{max}} &amp; \\text{if } \\sigma_H \\geq 0 \\\\\n        -\\sigma_{\\tau_{max}} &amp; \\text{if } \\sigma_H &lt; 0\n        \\end{cases}\n        $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n        rtol: Relative tolerance for comparing hydrostatic stress to zero.\n            Default is 1e-5.\n        atol: Absolute tolerance for comparing hydrostatic stress to zero.\n            Default is 1e-8.\n\n    Returns:\n        Array of shape (...). Signed Tresca stress for each entry.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    tresca = calc_tresca_stress(stress_vector_voigt)\n    hydrostatic_stress = calc_hydrostatic_stress(stress_vector_voigt)\n\n    sign = np.sign(hydrostatic_stress)\n    sign = np.where(np.isclose(hydrostatic_stress, 0, rtol=rtol, atol=atol), 1.0, sign)\n\n    return sign * tresca\n</code></pre>"},{"location":"api/#fatpy.struct_mech.stress.calc_signed_tresca_by_max_abs_principal","title":"<code>calc_signed_tresca_by_max_abs_principal(stress_vector_voigt, rtol=1e-05, atol=1e-08)</code>","text":"<p>Calculate signed Tresca stress for each stress state.</p> <p>Sign is determined by the maximum absolute principal stress value.</p> Sign Convention <p>The sign assignment follows these rules:</p> <ul> <li>Positive (+): When (\u03c3\u2081 + \u03c3\u2083)/2 &gt; 0 (tension dominant)</li> <li>Negative (-): When (\u03c3\u2081 + \u03c3\u2083)/2 &lt; 0 (compression dominant)</li> <li>Positive (+): When (\u03c3\u2081 + \u03c3\u2083)/2 \u2248 0 (within tolerance, default fallback)</li> </ul> <p>Tolerance parameters ensure numerical stability in edge cases where the determining value is very close to zero, preventing erratic sign changes that could occur due to floating-point precision limitations.</p> Math Equations \\[ \\sigma_{S\\tau_{max}} = \\begin{cases} +\\sigma_{\\tau_{max}} &amp; \\text{if } \\frac{\\sigma_1 + \\sigma_3}{2} \\geq 0 \\\\ -\\sigma_{\\tau_{max}} &amp; \\text{if } \\frac{\\sigma_1 + \\sigma_3}{2} &lt; 0 \\end{cases} \\] <p>Parameters:</p> Name Type Description Default <code>stress_vector_voigt</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6). The last dimension contains the Voigt stress components. Leading dimensions are preserved.</p> required <code>rtol</code> <code>float</code> <p>Relative tolerance for comparing the average of maximum and minimum principal stresses to zero. Default is 1e-5.</p> <code>1e-05</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for comparing the average of maximum and minimum principal stresses to zero. Default is 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array of shape (...). Signed Tresca stress for each entry. Tensor rank is reduced by one.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/struct_mech/stress.py</code> <pre><code>def calc_signed_tresca_by_max_abs_principal(\n    stress_vector_voigt: NDArray[np.float64],\n    rtol: float = 1e-5,\n    atol: float = 1e-8,\n) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate signed Tresca stress for each stress state.\n\n    Sign is determined by the maximum absolute principal stress value.\n\n    ??? note \"Sign Convention\"\n        The sign assignment follows these rules:\n\n        - **Positive (+)**: When (\u03c3\u2081 + \u03c3\u2083)/2 &gt; 0 (tension dominant)\n        - **Negative (-)**: When (\u03c3\u2081 + \u03c3\u2083)/2 &lt; 0 (compression dominant)\n        - **Positive (+)**: When (\u03c3\u2081 + \u03c3\u2083)/2 \u2248 0 (within tolerance, default fallback)\n\n    Tolerance parameters ensure numerical stability in edge cases where the\n    determining value is very close to zero, preventing erratic sign changes\n    that could occur due to floating-point precision limitations.\n\n    ??? abstract \"Math Equations\"\n        $$\n        \\sigma_{S\\tau_{max}} = \\begin{cases}\n        +\\sigma_{\\tau_{max}} &amp; \\text{if } \\frac{\\sigma_1 + \\sigma_3}{2} \\geq 0 \\\\\n        -\\sigma_{\\tau_{max}} &amp; \\text{if } \\frac{\\sigma_1 + \\sigma_3}{2} &lt; 0\n        \\end{cases}\n        $$\n\n    Args:\n        stress_vector_voigt: Array of shape (..., 6). The last dimension contains the\n            Voigt stress components. Leading dimensions are preserved.\n        rtol: Relative tolerance for comparing the average of maximum and minimum\n            principal stresses to zero. Default is 1e-5.\n        atol: Absolute tolerance for comparing the average of maximum and minimum\n            principal stresses to zero. Default is 1e-8.\n\n    Returns:\n        Array of shape (...). Signed Tresca stress for each entry.\n            Tensor rank is reduced by one.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    tresca = calc_tresca_stress(stress_vector_voigt)\n    principals = calc_principal_stresses(stress_vector_voigt)\n\n    avg_13 = 0.5 * (principals[..., 0] + principals[..., 2])\n    sign = np.sign(avg_13).astype(np.float64, copy=False)\n    sign = np.where(np.isclose(avg_13, 0, rtol=rtol, atol=atol), 1.0, sign)\n\n    return sign * tresca\n</code></pre>"},{"location":"api/#fatpy.struct_mech.transformations","title":"<code>transformations</code>","text":"<p>Transformations methods of structural mechanics.</p> <p>These routines perform mathematical operations to transform stress and strain tensors between different coordinate systems or reference frames. They include tensor rotation, transformation to principal axes, and projection onto specified planes, enabling detailed analysis of material response under complex loading conditions and supporting criteria based on critical plane, invariant, or principal stress/strain approaches. Includes 5D deviatoric stress reduction.</p>"},{"location":"api/#fatpy.utils","title":"<code>utils</code>","text":"<p>Utilities module.</p> <p>A collection of general utility functions.</p>"},{"location":"api/#fatpy.utils.mesh","title":"<code>mesh</code>","text":"<p>Mesh processing utilities module.</p> <p>This module provides various functions and classes for mesh processing tasks.</p>"},{"location":"api/#fatpy.utils.signal","title":"<code>signal</code>","text":"<p>Signal processing utilities module.</p> <p>This module provides various functions and classes for signal processing tasks.</p>"},{"location":"api/#fatpy.utils.voigt","title":"<code>voigt</code>","text":"<p>Tools for working with Voigt notation in continuum mechanics.</p> Overview <p>This module provides general utilities for handling vectors and tensors represented in Voigt notation. Voigt notation is widely used to express symmetric 3x3 tensors, such as stress and strain, in a compact vector form.</p> Input Shape Convention <ul> <li>Arrays are expected to have shape (..., 6), where the last dimension   contains the six Voigt components:       (\u03c3_11, \u03c3_22, \u03c3_33, \u03c3_23, \u03c3_13, \u03c3_12)       (\u03c3_xx, \u03c3_yy, \u03c3_zz, \u03c3_yz, \u03c3_xz, \u03c3_xy)   Leading dimensions (the '...' part) are preserved and can be arbitrary,   allowing batch processing of multiple vectors or tensors.</li> </ul>"},{"location":"api/#fatpy.utils.voigt.check_shape","title":"<code>check_shape(vector)</code>","text":"<p>Validate the Voigt vector shape.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>NDArray[float64]</code> <p>Array with shape (..., 6) where the last dimension has length 6.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/utils/voigt.py</code> <pre><code>def check_shape(vector: NDArray[np.float64]) -&gt; None:\n    \"\"\"Validate the Voigt vector shape.\n\n    Args:\n        vector: Array with shape (..., 6) where the last dimension has length 6.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    if vector.shape[-1] != VOIGT_COMPONENTS_COUNT:\n        raise ValueError(\n            \"Last dimension must correspond to 6 Voigt \"\n            \"stress/strain components (..., 6).\"\n        )\n</code></pre>"},{"location":"api/#fatpy.utils.voigt.voigt_to_tensor","title":"<code>voigt_to_tensor(vector)</code>","text":"<p>Convert Voigt vectors to symmetric 3x3 tensors.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>NDArray[float64]</code> <p>Array of shape (..., 6) where the last dimension contains the stress/strain components in order according to Voigt notation:     (\u03c3_11, \u03c3_22, \u03c3_33, \u03c3_23, \u03c3_13, \u03c3_12)     (\u03c3_xx, \u03c3_yy, \u03c3_zz, \u03c3_yz, \u03c3_xz, \u03c3_xy)</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array with shape (..., 3, 3). The last two axes are the symmetric</p> <code>NDArray[float64]</code> <p>3x3 tensor for each input index. Leading dimensions are preserved.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last dimension is not of size 6.</p> Source code in <code>src/fatpy/utils/voigt.py</code> <pre><code>def voigt_to_tensor(vector: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n    \"\"\"Convert Voigt vectors to symmetric 3x3 tensors.\n\n    Args:\n        vector: Array of shape (..., 6) where the last dimension contains the\n            stress/strain components in order according to Voigt notation:\n                (\u03c3_11, \u03c3_22, \u03c3_33, \u03c3_23, \u03c3_13, \u03c3_12)\n                (\u03c3_xx, \u03c3_yy, \u03c3_zz, \u03c3_yz, \u03c3_xz, \u03c3_xy)\n\n    Returns:\n        Array with shape (..., 3, 3). The last two axes are the symmetric\n        3x3 tensor for each input index. Leading dimensions are preserved.\n\n    Raises:\n        ValueError: If the last dimension is not of size 6.\n    \"\"\"\n    check_shape(vector)\n\n    # (1e6, 50, 8, 6) -&gt; (1e6, 50, 8) + (3, 3) -&gt; (1e6, 50, 8, 3, 3)\n    shape = vector.shape[:-1] + (3, 3)\n    tensor = np.zeros(shape, dtype=vector.dtype)\n\n    # Normal components\n    tensor[(..., 0, 0)] = vector[..., 0]  # xx\n    tensor[(..., 1, 1)] = vector[..., 1]  # yy\n    tensor[(..., 2, 2)] = vector[..., 2]  # zz\n\n    # Shear components\n    tensor[(..., [1, 2], [2, 1])] = vector[..., [3]]  # yz\n    tensor[(..., [0, 2], [2, 0])] = vector[..., [4]]  # xz\n    tensor[(..., [0, 1], [1, 0])] = vector[..., [5]]  # xy\n\n    return tensor\n</code></pre>"},{"location":"api/#fatpy.utils.voigt.tensor_to_voigt","title":"<code>tensor_to_voigt(tensor)</code>","text":"<p>Convert symmetric 3x3 tensors to Voigt vectors.</p> <p>Parameters:</p> Name Type Description Default <code>tensor</code> <code>NDArray[float64]</code> <p>Array of shape (..., 3, 3) where the last two dimensions represent symmetric 3x3 tensors.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>Array with shape (..., 6). The last dimension contains the stress/strain</p> <code>NDArray[float64]</code> <p>components in order according to Voigt notation: (\u03c3_11, \u03c3_22, \u03c3_33, \u03c3_23, \u03c3_13, \u03c3_12) (\u03c3_xx, \u03c3_yy, \u03c3_zz, \u03c3_yz, \u03c3_xz, \u03c3_xy)</p> <code>NDArray[float64]</code> <p>Leading dimensions are preserved.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the last two dimensions are not of size (3, 3).</p> Source code in <code>src/fatpy/utils/voigt.py</code> <pre><code>def tensor_to_voigt(tensor: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n    \"\"\"Convert symmetric 3x3 tensors to Voigt vectors.\n\n    Args:\n        tensor: Array of shape (..., 3, 3) where the last two dimensions\n            represent symmetric 3x3 tensors.\n\n    Returns:\n        Array with shape (..., 6). The last dimension contains the stress/strain\n        components in order according to Voigt notation:\n            (\u03c3_11, \u03c3_22, \u03c3_33, \u03c3_23, \u03c3_13, \u03c3_12)\n            (\u03c3_xx, \u03c3_yy, \u03c3_zz, \u03c3_yz, \u03c3_xz, \u03c3_xy)\n        Leading dimensions are preserved.\n\n    Raises:\n        ValueError: If the last two dimensions are not of size (3, 3).\n    \"\"\"\n    if tensor.shape[-2:] != (3, 3):\n        raise ValueError(\"Last two dimensions must correspond to (3, 3) tensors.\")\n\n    shape = tensor.shape[:-2] + (VOIGT_COMPONENTS_COUNT,)\n    array = np.zeros(shape, dtype=tensor.dtype)\n\n    # Normal components\n    array[..., 0] = tensor[..., 0, 0]  # xx\n    array[..., 1] = tensor[..., 1, 1]  # yy\n    array[..., 2] = tensor[..., 2, 2]  # zz\n\n    # Shear components\n    array[..., 3] = tensor[..., 1, 2]  # yz\n    array[..., 4] = tensor[..., 0, 2]  # xz\n    array[..., 5] = tensor[..., 0, 1]  # xy\n\n    return array\n</code></pre>"},{"location":"development/","title":"Development Guide","text":"<p>This section provides comprehensive resources to help you contribute to FatPy, a Python package for fatigue life evaluation of materials, part of the FABER project.</p> <p> Learn About FABER</p> <p>About</p> <p>FatPy emphasizes code quality, thorough documentation, and rigorous testing. Whether you're fixing bugs or adding features, this guide will help you become a successful contributor.</p>"},{"location":"development/#getting-started","title":"Getting Started","text":"<p>New to FatPy? Start with these resources to set up your environment and understand how to contribute effectively:</p> <ul> <li> Installation Guide   Set up your development environment for FatPy.</li> <li> Contributing Guide   Learn how to contribute code, documentation, or ideas to the project.</li> <li> Code of Conduct   Understand our community standards for respectful collaboration.</li> </ul>"},{"location":"development/#development-resources","title":"Development Resources","text":"<p>Deepen your understanding of FatPy development with these resources:</p> <ul> <li> Code Style   Follow our coding standards for consistent, high-quality code.</li> <li> Documentation   Learn best practices for writing and maintaining FatPy documentation.</li> <li> Testing   Understand how to write and run tests to ensure code reliability.</li> <li> CI/CD Process   Explore our continuous integration and deployment workflow.</li> </ul> Additional resources <ul> <li>Join our GitHub Discussions for community support.</li> <li>Find contribution ideas in our GitHub Issues.</li> </ul> <p>Get a detailed overview of FatPy\u2019s modules and functions, visit API Reference.</p>"},{"location":"development/#development-workflow","title":"Development Workflow","text":"<p>Follow our development workflow:</p> <ol> <li>Set Up Your Environment Installation Guide</li> <li> <p>Create a Feature Branch </p> <pre><code>git checkout -b feature-name\n</code></pre> </li> <li> <p>Implement the Feature     Follow the Code Style Guide.</p> </li> <li>Write and Run Tests Testing Guide</li> <li>Document your Changes     Use Documentation resources!</li> <li>Submit a pull request Contributing Guide</li> </ol>"},{"location":"development/#getting-help","title":"Getting Help","text":"<p>Need assistance with FatPy development? Reach out through these channels:</p> <ul> <li> GitHub Discussions     Join for community support.</li> <li> Report an Issue     Create an issue on our GitHub repository for bugs or questions.</li> <li> Contact our Team     Visit our contact page.</li> </ul> <p>Thank you for contributing to FatPy!</p>"},{"location":"development/ci_cd/","title":"CI/CD Process for FatPy","text":""},{"location":"development/ci_cd/#overview","title":"Overview","text":"<p>FatPy uses GitHub Actions to automate testing, validation, documentation building, and deployment processes. This continuous integration and deployment (CI/CD) workflow ensures code quality and simplifies releases.</p>"},{"location":"development/ci_cd/#ci-pipeline-components","title":"CI Pipeline Components","text":""},{"location":"development/ci_cd/#1-python-ci","title":"1. Python CI","text":"<p>Triggered by:</p> <ul> <li>Pushes to <code>main</code> branch</li> <li>Pull requests to <code>main</code> branch</li> </ul> <p>Configuration file: <code>.github/workflows/python-ci.yml</code></p> Steps: <ol> <li>Checkout code: Retrieves the repository code</li> <li>Setup Python: Configures Python 3.12 environment</li> <li>Install dependencies: Installs required packages</li> <li>Run type checks: Validates typing with mypy</li> <li>Run linter: Checks code quality with ruff</li> <li>Run tests: Executes pytest test suite</li> <li>Test documentation build: Ensures docs build successfully</li> </ol>"},{"location":"development/ci_cd/#2-documentation-deployment","title":"2. Documentation Deployment","text":"<p>Triggered by:</p> <ul> <li>Pushes to <code>documentation</code> branch</li> <li>Manual trigger via workflow_dispatch</li> </ul> <p>Configuration file: <code>.github/workflows/deploy_docs.yml</code></p> Steps: <ol> <li>Checkout repository: Retrieves the repository code</li> <li>Setup Python: Configures Python environment</li> <li>Install dependencies: Installs documentation tools</li> <li>Deploy: Builds and deploys documentation to GitHub Pages</li> </ol>"},{"location":"development/ci_cd/#3-pypi-publication","title":"3. PyPI Publication","text":"<p>Triggered by:</p> <ul> <li>Release tags (v..*)</li> </ul> <p>Configuration file: <code>.github/workflows/publish_pypi.yml</code></p> Steps: <ol> <li>Checkout code: Retrieves the repository code</li> <li>Setup Python: Configures Python environment</li> <li>Install dependencies: Installs build tools</li> <li>Build package: Creates distribution packages</li> <li>Publish to PyPI: Uploads built packages to PyPI</li> </ol>"},{"location":"development/ci_cd/#4-github-release-creation","title":"4. GitHub Release Creation","text":"<p>Triggered by:</p> <ul> <li>Release tags (v..*)</li> </ul> <p>Configuration file: <code>.github/workflows/github_release.yml</code></p> Steps: <ol> <li>Checkout: Retrieves the repository code</li> <li>Create GitHub Release: Creates a new release on GitHub</li> </ol>"},{"location":"development/ci_cd/#release-process","title":"Release Process","text":"<p>Follow these steps to release a new FatPy version:</p> <ol> <li>Update version: In <code>pyproject.toml</code></li> <li>Update changelog: Document changes</li> <li>Merge to main: Ensure all changes are in the main branch</li> <li>Create tag: <code>git tag -a v0.1.0 -m \"Release v0.1.0\"</code></li> <li>Push tag: <code>git push origin v0.1.0</code></li> </ol> <p>Note</p> <p>Pushing the tag automatically triggers:</p> <ul> <li>Package publishing to PyPI</li> <li>GitHub release creation</li> </ul>"},{"location":"development/ci_cd/#viewing-results","title":"Viewing Results","text":"<p>Monitor CI/CD outcomes to ensure successful workflows:</p>"},{"location":"development/ci_cd/#cicd-status","title":"CI/CD Status","text":"<ol> <li>Go to the GitHub repository</li> <li>Click on the \"Actions\" tab</li> <li>Select a workflow run to see detailed results</li> </ol>"},{"location":"development/ci_cd/#status-badges","title":"Status Badges","text":"<p>Status badges are displayed in the README.md:</p> <pre><code>![Python CI](https://github.com/faberorg/fatpy/workflows/Python%20CI/badge.svg)\n![Documentation](https://github.com/faberorg/fatpy/workflows/Deploy%20Documentation/badge.svg)\n</code></pre>"},{"location":"development/ci_cd/#troubleshooting-ci-failures","title":"Troubleshooting CI Failures","text":""},{"location":"development/ci_cd/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"Failed TestsType ErrorsStyle ViolationsDocumentation Build Failures <ul> <li>Issue: Tests failing in CI but passing locally</li> <li>Solutions:</li> <li>Check Python version differences</li> <li>Check dependency versions</li> <li>Review test logs for environment-specific issues</li> </ul> <ul> <li>Issue: Mypy reports type errors</li> <li>Solutions:</li> <li>Run <code>mypy</code> locally: <code>mypy .</code></li> <li>Fix type annotations</li> <li>Add appropriate type stubs if needed</li> </ul> <ul> <li>Issue: Ruff reports style issues</li> <li>Solutions:</li> <li>Run <code>ruff check .</code> locally</li> <li>Fix style issues: <code>ruff check --fix .</code></li> <li>Format code: <code>ruff format .</code></li> </ul> <ul> <li>Issue: MkDocs build fails</li> <li>Solutions:</li> <li>Run <code>mkdocs build --strict</code> locally</li> <li>Check for broken links</li> <li>Verify markdown syntax</li> </ul>"},{"location":"development/ci_cd/#adding-new-workflows","title":"Adding New Workflows","text":"<p>To add a new CI/CD workflows to enhance FatPy\u2019s automation:</p> <ol> <li>Create a YAML file in <code>.github/workflows/</code></li> <li>Define the workflow triggers and steps</li> <li>Test the workflow using <code>workflow_dispatch</code> if possible</li> </ol>"},{"location":"development/ci_cd/#security-considerations","title":"Security Considerations","text":"<p>Warning</p> <p>Ensure secure CI/CD practices for FatPy:</p> <ul> <li>Secrets: Sensitive information is stored as GitHub secrets</li> <li>Token Access: PyPI token has limited scope</li> <li>Dependencies: Regular updates to minimize vulnerabilities</li> </ul>"},{"location":"development/ci_cd/#best-practices","title":"Best Practices","text":"<ul> <li>Test locally: Run checks locally before pushing</li> <li>Small changes: Make smaller, focused changes</li> <li>Review logs: Check CI logs to understand failures</li> <li>Update documentation: Update CI documentation when changing workflows</li> </ul>"},{"location":"development/code_of_conduct/","title":"Code of Conduct","text":""},{"location":"development/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We pledge to make participation in our project a respectful and inclusive experience for everyone, regardless of their background or personal characteristics. This includes, but is not limited to, individuals of any age, personal appearance, disability, ethnicity, level of experience, nationality, race, religion, political beliefs, or sexual orientation.</p>"},{"location":"development/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others\u2019 private information, such as a physical or electronic address, without explicit permission</li> </ul>"},{"location":"development/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at jan.vyborny2@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances.</p>"},{"location":"development/code_style/","title":"Code Style Guide","text":"<p>This guide defines coding standards and style to ensure readable and consistent code for FatPy project.</p>"},{"location":"development/code_style/#general-principles","title":"General Principles","text":"<ul> <li>Readability - Code should be easy to read and to understand</li> <li>Consistency - Follow established patterns and conventions</li> <li>Simplicity - Prefer simple solutions over complex ones</li> <li>Documentation - Code should be well-documented</li> </ul>"},{"location":"development/code_style/#python-style-guidelines","title":"Python Style Guidelines","text":"<p>FatPy follows PEP 8 with some specific adaptations:</p> Naming ConventionsCode LayoutImports <ul> <li>Functions and variables: <code>lowercase_with_underscores</code></li> <li>Classes: <code>CamelCase</code></li> <li>Constants: <code>UPPERCASE_WITH_UNDERSCORES</code></li> <li>Private attributes/methods: <code>_leading_underscore</code></li> <li>\"Magic\" methods: <code>__double_underscores__</code></li> </ul> <ul> <li>Line length: 120 characters maximum</li> <li>Indentation: 4 spaces (no tabs)</li> <li>Blank lines:</li> <li>2 between top-level functions and classes</li> <li>1 between methods in a class</li> <li>Use blank lines to separate logical sections within functions</li> </ul> <ul> <li>Organize imports as follows:</li> <li>Standard library imports</li> <li>Third-party imports</li> <li>Local application imports</li> <li>Each group should be separated by a blank line</li> <li>Within each group, imports should be alphabetized</li> </ul> <pre><code># Standard library\nimport os\nimport sys\nfrom typing import Dict, List, Optional\n\n# Third-party libraries\nimport numpy as np\nimport pandas as pd\n\n# Local modules\nfrom fatpy.core import analysis\nfrom fatpy.utilities import helpers\n</code></pre>"},{"location":"development/code_style/#type-annotations","title":"Type Annotations","text":"<p>Note</p> <p>FatPy uses type hints extensively. All functions should include type annotations to enhance code clarity</p> <p>Example:</p> <pre><code>def calculate_stress(force: float, area: float) -&gt; float:\n    \"\"\"Calculate stress from force and area.\n\n    Args:\n        force: The applied force in Newtons\n        area: The cross-sectional area in square meters\n\n    Returns:\n        The stress in Pascals\n    \"\"\"\n    return force / area\n</code></pre> <p>See more examples </p>"},{"location":"development/code_style/#comments-and-documentation","title":"Comments and Documentation","text":"<ul> <li>Docstrings - Use Google-style for all modules, classes, and functions.</li> <li>Inline comments - Use sparingly and only for complex or non-obvious code.</li> <li>Keep Updated - Sync comments with code changes.</li> <li>Style Guide -   Follow Documentation Guide</li> </ul>"},{"location":"development/code_style/#code-quality-tools","title":"Code Quality Tools","text":"<p>FatPy uses several tools to enforce code quality:</p> <p> Ruff</p> <p>Handles linting and formatting.</p> <pre><code># Run linting\nruff check .\n\n# Apply fixes automatically\nruff check --fix .\n\n# Format code\nruff format .\n</code></pre> <p> MyPy</p> <p>Enforces static type checking.</p> <pre><code># Run type checking\nmypy .\n</code></pre> <p> Pre-commit</p> <p>Automates and run code checks before commits.</p> <pre><code># Install the pre-commit hooks\npre-commit install\n\n# Run pre-commit on all files\npre-commit run --all-files\n</code></pre>"},{"location":"development/code_style/#best-practices","title":"Best Practices","text":""},{"location":"development/code_style/#general","title":"General","text":"<ul> <li>Keep functions and methods small and focused on a single task</li> <li>Limit function parameters to improve usability</li> <li>Use appropriate error handling and validation</li> <li>Write self-documenting code (clear variable names, logical structure)</li> </ul>"},{"location":"development/code_style/#performance","title":"Performance","text":"<ul> <li>Consider the computational complexity of your code</li> <li>Use vectorized operations with NumPy when working with numerical data</li> <li>Avoid premature optimization</li> </ul>"},{"location":"development/code_style/#testing","title":"Testing","text":"<ul> <li>Write tests for all new functionality</li> <li>Use descriptive test names that indicate what's being tested</li> <li>For more details, see:  Testing Guide</li> </ul>"},{"location":"development/code_style/#examples","title":"Examples","text":""},{"location":"development/code_style/#preferred-style","title":"Preferred Style","text":"<pre><code>import numpy as np\nfrom numpy.typing import NDArray\n\n\ndef calculate_stress(forces: NDArray[np.float64], area: float) -&gt; float:\n    \"\"\"Calculate stress from force and area.\n\n    Args:\n        forces: Numpy array of forces\n        area: The cross-sectional area\n\n    Returns:\n        The stress value\n\n    Raises:\n        ValueError: If area is less than or equal to zero\n    \"\"\"\n\n    if area &lt;= 0:\n        raise ValueError(\"Area must be greater than zero\")\n\n    total_force = np.sum(forces)\n\n    return total_force / area\n</code></pre> <pre><code>class FatigueAnalyzer:\n    \"\"\"Class for performing fatigue analysis.\"\"\"\n\n    def __init__(self, material_name: str, safety_factor: float = 1.5) -&gt; None:\n        \"\"\"Initialize the fatigue analyzer.\n\n        Args:\n            material_name: Name of the material to analyze\n            safety_factor: Safety factor to apply in calculations\n        \"\"\"\n        self.material_name = material_name\n        self.safety_factor = safety_factor\n        self._results: list[float] = []\n</code></pre>"},{"location":"development/contributing/","title":"Contributing to FatPy","text":"<p>Thank you for considering contributing to FatPy, a Python package for fatigue life evaluation of materials, part of the FABER project! Your contributions help improve open source tools for fatigue analysis. Start with these steps to make an impact.</p> <p> Learn About FABER</p>"},{"location":"development/contributing/#quick-start","title":"Quick Start","text":"<p>Get started contributing to FatPy in a few simple steps:</p> <ol> <li>Fork the Repository Create a personal copy on GitHub.</li> <li>Clone Your Fork </li> </ol> <pre><code>git clone https://github.com/your-username/FatPy.git  # Clone your fork\n</code></pre> <ol> <li>Create a Branch </li> </ol> <pre><code>git checkout -b my-feature-branch  # Create a new branch for your feature\n</code></pre> <ol> <li>Implement the Feature Write code to pass your tests.</li> <li>Write Tests for Your Feature Define expected behavior first.</li> <li>Submit a Pull Request Share your changes for review.</li> </ol>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<pre><code># Clone the repository\ngit clone https://github.com/your-username/FatPy.git\ncd FatPy\n\n# Using uv (recommended)\nuv venv\n.venv\\Scripts\\activate  # On Unix: source .venv/bin/activate\nuv sync\nuv pip install -e .\npre-commit install\n\n# Using pip\npython -m venv venv\nvenv\\Scripts\\activate  # On Unix: source venv/bin/activate\npip install -r requirements.txt\npip install -r requirements-dev.txt\npip install -e .\npre-commit install\n</code></pre> <p>For detailed configuration of your development environment, see the Installation Guide </p>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>FatPy emphasizes comprehensive testing to ensure code reliability and quality. All contributions should include appropriate tests and maintain high test coverage.</p>"},{"location":"development/contributing/#testing-guidelines","title":"Testing Guidelines","text":"<ul> <li>Write comprehensive tests - Cover all functionality with unit and integration tests</li> <li>Test edge cases - Include boundary conditions and error scenarios  </li> <li>Maintain test coverage - Aim for high coverage to ensure reliability</li> <li>Keep tests updated - Update tests when modifying existing functionality</li> <li>Use clear test names - Write descriptive test names and docstrings</li> </ul>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/core/test_specific_module.py\n\n# Test with coverage report\npytest --cov=src/fatpy --cov-report=html\n</code></pre> <p>For more details, see the Testing Guide </p>"},{"location":"development/contributing/#coding-standards","title":"Coding Standards","text":"<p>FatPy aims for high code quality utilizing these tools:</p> <ul> <li>Ruff  - Linting and formatting for consistent code style.</li> <li>MyPy  - Static type checking for reliability.</li> <li>Pre-commit - Automated checks before commits.</li> </ul> <p>Follow our coding standards for contributions, see Code Style Guide  </p>"},{"location":"development/contributing/#running-code-quality-checks","title":"Running Code Quality Checks","text":"<pre><code># Run linting\nruff check .\n\n# Apply fixes automatically\nruff check --fix .\n\n# Format code\nruff format .\n\n# Run type checking\nmypy .\n\n# Run pre-commit on all files\npre-commit run --all-files\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<p>Keep FatPy\u2019s documentation clear and up-to-date with these guidelines:</p> <ul> <li>API Changes Update documentation for any API modifications.</li> <li>Docstrings Add docstrings following Google style to all new code.</li> <li>Examples Include examples and mathematical formulas where helpful to aid users.</li> </ul> <p>Learn best practices and guidelines for documentation, see Documentation Guide </p>"},{"location":"development/contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Activate project environment\n.\\{environment_name}\\Scripts\\activate\n\n# Build and serve documentation locally\nmkdocs serve\n</code></pre>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<p>Submit a high-quality pull request with these steps:</p> <ol> <li>Run Tests and Checks    Ensure tests pass and code quality checks succeed.</li> <li>Update Documentation    Reflect changes in relevant docs.</li> <li>Link Issues    Reference related GitHub issues.</li> <li>Follow guidelines    Make sure your code follows the project's style guidelines.</li> <li>Await Review    Respond to feedback from maintainers.</li> </ol>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors must follow our standards.</p> <p>Understand our expectations for collaboration, see Code of Conduct </p>"},{"location":"development/contributing/#ideas-and-questions","title":"Ideas and Questions","text":"<p>Join discussion, create an issue or reach out to maintainers:</p> <ul> <li> GitHub Discussions      Join for community support.</li> <li> Report an Issue      Create an issue on our GitHub repository for bugs or questions.</li> <li> Contact our Team      Visit our contact page.</li> </ul> <p>Thank you for contributing to FatPy!</p>"},{"location":"development/documentation/","title":"Documentation Guide","text":"<p>Good documentation ensures FatPy is usable and maintainable for researchers, engineers, and contributors. This guide outlines our standards to support FatPy\u2019s role in the FABER project.</p>"},{"location":"development/documentation/#documentation-structure","title":"Documentation Structure","text":"<p>FatPy\u2019s documentation is organized into the following sections to support diverse user needs:</p> <ul> <li> <p> API Reference</p> <p>Detailed documentation for modules, classes, and functions.</p> </li> <li> <p> Theory Reference</p> <p>Mathematical and physical background for implemented fatigue analysis methods.</p> </li> <li> <p> Development Guide</p> <p>Resources for contributors, including setup and contribution guidelines.</p> </li> <li> <p> Tutorials and Examples</p> <p>Practical guides and examples for using FatPy.</p> </li> </ul>"},{"location":"development/documentation/#docstrings","title":"Docstrings","text":"<p>Note</p> <p>All modules, classes, and functions must include Google-style docstrings with:</p> <ul> <li>A short description</li> <li>Args, Returns, Raises sections</li> <li>Optional LaTeX formulas and code examples</li> <li>Detailed explanation (if needed)</li> </ul> example_module.py<pre><code>def example_function(param1: int, param2: str) -&gt; bool:\n    \"\"\"Short description of the function.\n\n    More detailed explanation if needed. This can span\n    multiple lines and include more information.\n\n    ??? abstract \"Math Equations\"\n        Mathematical formulas can be included using LaTeX syntax:\n\n        $$ y = f(x) $$\n\n    Args:\n        param1: Description of the first parameter\n        param2: Description of the second parameter\n\n    Returns:\n        Description of the return value\n\n    Raises:\n        ValueError: When an invalid value is provided\n\n    Example:\n        ```python\n        result = example_function(42, \"test\")\n        print(result)  # Output: True\n        ```\n    \"\"\"\n    # Function implementation\n    return True\n</code></pre>"},{"location":"development/documentation/#building-documentation","title":"Building Documentation","text":"<p>We use MkDocs with the Material theme and mkdocstrings for API documentation, see references </p> <p>You can build and preview FatPy\u2019s documentation locally using MkDocs commands:</p> <pre><code># Activate project environment\n.\\{environment_name}\\Scripts\\activate\n\n# Install documentation dependencies\npip install mkdocs mkdocs-material mkdocstrings[python] mkdocs-autorefs\n\n# Build documentation locally\nmkdocs build\n\n# Serve documentation locally with hot-reloading\nmkdocs serve\n</code></pre> <p>The <code>mkdocs serve</code> command will provide you with link <code>http://127.0.0.1:8000</code> to view the documentation locally.</p>"},{"location":"development/documentation/#writing-documentation","title":"Writing Documentation","text":"<p>Follow these guidelines to create clear and effective documentation for FatPy.</p>"},{"location":"development/documentation/#general-guidelines","title":"General Guidelines","text":"<ul> <li>Clear Language   Use concise, straightforward wording.</li> <li>Examples   Include practical code or use-case examples, where possible.</li> <li>Related Links   Reference related documentation.</li> <li>Headers   Organize content with clear section headings.</li> <li>Mathematical Formulas   Use LaTeX for mathematical notation where appropriate.</li> </ul>"},{"location":"development/documentation/#fatpy-naming-conventions","title":"FatPy Naming Conventions","text":"<p>Consistent naming is crucial for code readability and maintainability. Follow these conventions alongside the standard Python's PEP 8 style when contributing to FatPy.</p>  Method &amp; Function Naming Parameter &amp; Variable Naming Common Abbreviations &amp; Shortcuts <ul> <li>Use <code>snake_case</code>: All function and method names should be lowercase with words separated by underscores.     <pre><code>def calc_stress_von_mises():\n    pass\n</code></pre></li> <li>Calculation functions: utilize <code>calc_</code> prefix in the function name signature.</li> </ul> <ul> <li>Use <code>snake_case</code>: All parameter and variable names should be lowercase with words separated by underscores.     <pre><code>def example_function(stress_amp, cycle_count):\n    mean_stress = 0  # Example variable\n    # ...\n</code></pre></li> <li>Clarity over Brevity: Choose names that are easy to understand.<ul> <li>Good: <code>eq_stress_amp</code> (see common abbreviations and shortcuts)</li> <li>Avoid: <code>s</code>, <code>val</code>, <code>x1</code> (if context is not immediately obvious)</li> </ul> </li> <li>Units (Optional but Recommended in Docstrings): While not part of the variable name itself, always specify units in docstrings for physical quantities.     <pre><code>def calc_force(mass: float, acceleration: float) -&gt; float:\n    \"\"\"Calculates force.\n\n    $$ F = m \\cdot a $$\n\n    Args:\n        mass: Mass of the object [kg]\n        acceleration: Acceleration [$$ ms^2 $$]\n\n    Returns:\n        Force [N]\n    \"\"\"\n    return mass * acceleration\n</code></pre></li> </ul> <p>Use abbreviations sparingly and only when they are widely understood within the fatigue analysis domain or clearly defined within the project.</p> <ul> <li><code>eq</code>: equivalent (e.g., <code>eq_stress</code> for equivalent stress)</li> <li><code>amp</code>: amplitude (e.g., <code>stress_amp</code> for stress amplitude)</li> <li><code>mean</code>: mean (e.g., <code>mean_stress</code>)</li> <li><code>max</code>: maximum (e.g., <code>max_principal_stress</code>)</li> <li><code>min</code>: minimum (e.g., <code>min_principal_stress</code>)</li> <li><code>fat</code>: fatigue (e.g., <code>fat_limit</code> for fatigue limit)</li> <li><code>frac</code>: fracture (e.g., <code>frac_toughness</code> for fracture toughness)</li> </ul> <p>Common names and material parameters: - <code>first_principal_stress</code>, <code>second_principal_stress</code> and <code>third_principal_stress</code> - <code>elastic_modulus</code>, <code>shear_modulus</code> and <code>poisson_ratio</code> - <code>ultimate_tensile_strength</code> and <code>yield_strength</code> </p> <p>Clarity First</p> <p>If an abbreviation makes the code harder to understand for someone new to the specific module or fatigue in general, prefer the full name. Document any project-specific abbreviations clearly.</p> <p>Learn more about the naming conventions form our discussion page:  </p> <p> Naming Conventions for FatPy Functions &amp; Parameters #18</p> <p>Best Practices</p> <ul> <li>Update documentation when you change code.</li> <li>Write documentation as you code, not after.</li> <li>Test documentation examples to ensure they work.</li> <li>Review documentation for clarity and correctness.</li> <li>Consider the reader's perspective and knowledge level.</li> </ul>"},{"location":"development/documentation/#mathematical-notation","title":"Mathematical Notation","text":"<p>Use LaTeX for mathematical formulas. This allows for clear rendering of equations. You can include math inline with text or as a separate display block.</p> Inline MathBlock SyntaxDisplay Complex Expression <p>Inline blocks must be enclosed in <code>$...$</code>, and can be used within a sentence.</p> <p>How to write it: Inline syntax<pre><code>Hooke's Law can be expressed as $\\sigma = E \\cdot \\epsilon$.\n</code></pre></p> <p>Rendered output: Hooke's Law can be expressed as \\(\\sigma = E \\cdot \\epsilon\\).</p> <p>This is typically used for important standalone equations. Blocks must be enclosed in <code>$$...$$</code>, and separated by empty lines form other text.</p> <p>How to write it: Block syntax<pre><code>% This line is empty\n$$ \n\\sigma_{eq} = \\sqrt{3J_2} = \\sqrt{\\frac{3}{2}s_{ij}s_{ij}}\n$$\n% This line is empty\n</code></pre></p> <p>Rendered output:</p> \\[ \\sigma_{eq} = \\sqrt{3J_2} = \\sqrt{\\frac{3}{2}s_{ij}s_{ij}} \\] <p>For more complex expressions, like summations, matrices, or a sequence of aligned equations.  </p> <p>This example shows Miner's rule for damage accumulation:</p> <p>How to write it: Sums or Integrals<pre><code>$$\n\\begin{gather}\nD = \\sum_{i=1}^{k} \\frac{n_i}{N_i} \\\\[2mm]\n\\text{or} \\\\[2mm]\nD = \\int_{0}^{N} \\frac{1}{N_f(\\sigma(t))} \\, dt\n\\end{gather}\n$$\n</code></pre></p> <p>Rendered output:</p> \\[ \\begin{gather} D = \\sum_{i=1}^{k} \\frac{n_i}{N_i} \\\\[2mm] \\text{or} \\\\[2mm] D = \\int_{0}^{N} \\frac{1}{N_f(\\sigma(t))} \\, dt \\end{gather} \\] <p>Multiple lines and spacing</p> <p>Use the <code>gather</code> environment to center equations, placing each on its own line. Separate lines with <code>\\\\</code>, and use <code>[2mm]</code> to adjust vertical spacing between them.</p> <p>To achieve precise alignment within equations, use aligned environment and the <code>&amp;</code> character to mark alignment points:</p> Aligned syntax<pre><code>$$\n\\begin{aligned}\n(a+b)^2 &amp;= (a+b)(a+b) \\\\\n        &amp;= a^2 + 2ab + b^2\n\\end{aligned}\n$$\n</code></pre> <p>Rendered output:</p> \\[ \\begin{aligned} (a+b)^2 &amp;= (a+b)(a+b) \\\\         &amp;= a^2 + 2ab + b^2 \\end{aligned} \\]"},{"location":"development/documentation/#api-documentation","title":"API Documentation","text":"<p>API documentation is automatically generated from docstrings using mkdocstrings. For this to work properly:</p> <ol> <li>All public functions, classes, and modules must have Google-style docstrings.</li> <li>Type hints should be used for all function parameters and return values.</li> <li>Examples should be included in docstrings where appropriate.</li> <li>Mathematical formulas should use LaTeX syntax within docstrings, e.g.: <code>$$ \\sigma = \\sqrt{x^2} $$</code></li> </ol> <p>View the generated API documentation:  API Reference</p>"},{"location":"development/documentation/#adding-new-pages","title":"Adding New Pages","text":"<p>To add new documentation pages, follow these steps:</p> <ul> <li>Create File   Add a new Markdown file in the appropriate directory (e.g., <code>docs/</code>).</li> <li>Update Navigation   Include the file in <code>mkdocs.yml</code> under the <code>nav</code> section.</li> <li>Format Content   Use headers, code blocks, and consistent Markdown formatting.</li> </ul> Documentation Deployment <p>Documentation is automatically deployed via GitHub Actions when changes are pushed to the documentation branch. The workflow is defined in <code>.github/workflows/deploy_docs.yml</code>.</p>"},{"location":"development/documentation/#documentation-resources","title":"Documentation Resources","text":"<ul> <li> <p> Markdown</p> <p>Markdown, the simple and easy-to-use markup language you can use to format virtually any document.</p> <p> Cheat Sheet  Basic Syntax</p> </li> <li> <p> Markdown DocsString</p> <p>In code documentation written in Markdown and automatically extracted into documentation.</p> <p> mkdocstring</p> </li> <li> <p> MkDocs</p> <p>MkDocs is a fast and simple static site generator that's geared towards building project documentation.</p> <p> MkDocs</p> </li> <li> <p> Material for MkDocs</p> <p>MkDocs Extension with various functionality including search, annotations, buttons and more!</p> <p> Materials for MkDocs</p> </li> </ul>"},{"location":"development/install/","title":"Installation Guide","text":""},{"location":"development/install/#prerequisites","title":"Prerequisites","text":"GeneralWindowsLinuxmacOS <ul> <li>Python 3.12 or higher</li> <li>Git</li> <li>pip or uv package manager</li> </ul> <ul> <li>Python 3.12 or higher (from python.org or Microsoft Store)</li> <li>Git for Windows (for development installation)</li> <li>Optional: uv package manager</li> </ul> <pre><code># Install Python 3.12+ (Ubuntu/Debian example)\nsudo apt update\nsudo apt install python3 python3-pip git\n\n# Install uv (optional)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code># Using Homebrew\nbrew install python\nbrew install git\n\n# Install uv (optional)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> Tip <p>Verify that the prerequisites are installed before setting up FatPy, by running following commands: <pre><code>uv --version\nuv python list\ngit --version\n</code></pre></p>"},{"location":"development/install/#standard-installation","title":"Standard Installation","text":"<p>The easiest way to install FatPy is from PyPI:</p> Using pipUsing uv <pre><code>pip install fatpy\n</code></pre> <p>Faster than standard pip installation.</p> <pre><code>uv pip install fatpy\n</code></pre> Tip <p>To install package and add dependency to your project .toml file use:</p> <pre><code>uv add fatpy # Install from PyPI and add dependency \n</code></pre> <p>This installs the latest stable release with all dependencies.</p>"},{"location":"development/install/#development-installation","title":"Development Installation","text":"<p>For contributing or customizing FatPy:</p> <ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/faberorg/fatpy.git\ncd fatpy\n</code></pre> <ol> <li>Setup development environment:</li> </ol> Using uv (recommended)Using pip <pre><code># Create and activate virtual environment\nuv venv\n.venv\\Scripts\\activate  # On Unix: source .venv/bin/activate\n\n# Install dependencies\nuv sync\n\n# Install in development mode\nuv pip install -e .\n\n# Setup pre-commit hooks\npre-commit install\n</code></pre> <p>The uv package manager is significantly faster than pip and provides better dependency resolution.</p> <pre><code># Create and activate virtual environment\npython -m venv venv\nvenv\\Scripts\\activate  # On Unix: source venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\npip install -r requirements-dev.txt\n\n# Install in development mode\npip install -e .\n\n# Setup pre-commit hooks\npre-commit install\n</code></pre> <p>The standard pip approach works on all systems with Python installed.</p>"},{"location":"development/install/#verifying-installation","title":"Verifying Installation","text":"<p>Run a simple test to verify the installation:</p> Quick TestRun Tests <pre><code># Import the library in Python\npython -c \"import fatpy; print(fatpy.__version__)\"\n</code></pre> <pre><code># Run the test suite\npytest -xvs\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":"<p>This guide outlines the testing approach and best practices for the FatPy project.</p>"},{"location":"development/testing/#testing-philosophy","title":"Testing Philosophy","text":"<p>FatPy emphasizes comprehensive testing to ensure code reliability and quality:</p> <ol> <li>Write comprehensive tests     Cover all functionality with appropriate unit and integration tests</li> <li>Test edge cases     Include boundary conditions and error scenarios</li> <li>Maintain test coverage     Aim for high test coverage to ensure code reliability</li> <li>Verify functionality     Ensure all tests pass before submitting changes</li> <li>Keep tests updated     Update tests when modifying existing functionality</li> <li>Document test cases     Use clear test names and docstrings to explain test purpose</li> </ol>"},{"location":"development/testing/#testing-framework","title":"Testing Framework","text":"<p>Info</p> <p>FatPy uses pytest for testing. The testing configuration can be found in the <code>pyproject.toml</code> file.</p>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>Tests are organized in the <code>tests/</code> directory, mirroring the structure of the <code>src/fatpy</code> package:</p> <pre><code>tests/\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 stress_life/\n\u2502   \u2502   \u251c\u2500\u2500 test_base_methods.py\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 strain_life/\n\u2502   \u2514\u2500\u2500 energy_life/\n\u251c\u2500\u2500 data_parsing/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 utilities/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 conftest.py       # Shared fixtures and configuration\n</code></pre>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/testing/#basic-test-structure","title":"Basic Test Structure","text":"<pre><code># Test a function\ndef test_addition():\n    # Arrange: Set up inputs\n    a = 2.0\n    b = 3.0\n    expected = 5.0\n\n    # Act: Call the function\n    result = addition(a, b)\n\n    # Assert: Verify output\n    assert result == expected\n\n# Test a class\ndef test_some_class_multiply():\n    # Arrange: Initialize class\n    value = 5.0\n    instance = SomeClass(value)\n    factor = 2.0\n    expected = 10.0\n\n    # Act: Test method\n    result = instance.multiply(factor)\n\n    # Assert: Check result\n    assert result == expected\n</code></pre> <p>Test Naming</p> <ul> <li>Test files should be named <code>test_*.py</code></li> <li>Test functions should be named <code>test_*</code></li> <li>Test classes should be named <code>Test*</code></li> </ul>"},{"location":"development/testing/#fixtures","title":"Fixtures","text":"<p>Use fixtures for setup and teardown:</p> <pre><code>import pytest\n\n\n@pytest.fixture\ndef sample_data(): # Fixture for sample data\n    \"\"\"Provide sample data for tests.\"\"\"\n    return {\n        \"stress\": [100.0, 200.0, 150.0],\n        \"cycles\": [1000, 100, 500]\n    }\n\n# The fixture is automatically passed to the test\ndef test_function_with_fixture(sample_data):\n    # Act: Use fixture data\n    result = process_data(sample_data[\"stress\"], sample_data[\"cycles\"])\n    # Assert: Verify result\n    assert result &gt; 0\n</code></pre>"},{"location":"development/testing/#parameterized-tests","title":"Parameterized Tests","text":"<p>Use parameterization to test multiple cases:</p> <pre><code>import pytest\n\n# Define test cases\n@pytest.mark.parametrize(\"input_value, expected_output\", [\n    (0.0, 0.0),\n    (1.0, 1.0),\n    (2.0, 4.0),\n    (3.0, 9.0),\n])\ndef test_square_function(input_value, expected_output):\n    assert square(input_value) == expected_output\n</code></pre>"},{"location":"development/testing/#testing-exceptions","title":"Testing Exceptions","text":"<p>Use pytest to verify that functions raise appropriate exceptions:</p> <pre><code>import pytest\n\n\ndef test_division_by_zero():\n    # Assert: Expect ValueError\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide(10.0, 0.0)\n</code></pre>"},{"location":"development/testing/#testing-categories","title":"Testing Categories","text":"<p>FatPy uses multiple test types to ensure reliability:</p>"},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":"<ul> <li>Test individual functions and methods</li> <li>Mock dependencies</li> <li>Should be fast and isolated</li> </ul>"},{"location":"development/testing/#integration-tests","title":"Integration Tests","text":"<ul> <li>Test interactions between components</li> <li>Use fewer mocks</li> <li>Verify that components work together correctly</li> </ul>"},{"location":"development/testing/#numerical-tests","title":"Numerical Tests","text":"<p>For mathematical functions, use appropriate numerical testing techniques:</p> <pre><code>def test_numerical_function():\n    # Act: Compute value\n    result = calculate_value(3.14159)\n    expected = 2.71828\n    # Assert: Compare floats\n    assert result == pytest.approx(expected, rel=1e-5)\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<p>Run tests using pytest commands:</p> <pre><code># Run all tests\npytest\n\n# Run specific test file\npytest tests/core/test_specific_module.py\n\n# Run with verbose output\npytest -v\n\n# Run with coverage report\npytest --cov=src/fatpy\n\n# Run specific test\npytest tests/core/test_module.py::test_specific_function\n</code></pre>"},{"location":"development/testing/#code-coverage","title":"Code Coverage","text":"<p>FatPy aims for high test coverage. Coverage reports can be generated with:</p> <pre><code>pytest --cov=src/fatpy --cov-report=html\n</code></pre> <p>Open <code>htmlcov/index.html</code> to view the coverage report.</p>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":"<p>Follow these practices to write effective tests for FatPy:</p> <ol> <li>Keep tests simple - Each test should verify one specific behavior</li> <li>Use descriptive names - Test names should describe what's being tested</li> <li>Avoid test interdependence - Tests should not depend on each other</li> <li>Clean up after tests - Use fixtures for setup and teardown</li> <li>Test edge cases - Include tests for boundary conditions and error handling</li> <li>Keep tests fast - Slow tests discourage frequent testing</li> <li>Use appropriate assertions - Choose the right assertion for each test case</li> <li>Don't test implementation details - Test behavior, not implementation</li> </ol>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests are automatically run on GitHub Actions when code is pushed or a pull request is created. See the FatPy\u2019s CI/CD setup for more information.</p>"},{"location":"theory/","title":"Theoretical Background","text":"<p>This section provides the mathematical and physical foundations for the fatigue analysis methods implemented in FatPy.</p>"},{"location":"theory/#approaches-to-fatigue-analysis","title":"Approaches to Fatigue Analysis","text":"<p>FatPy implements several fundamental approaches to fatigue life prediction:</p> <ul> <li>Stress Life: Methods based on stress-based approaches</li> <li>Strain Life: Methods based on strain-based approaches</li> <li>Energy Life: Methods based on energy-based approaches</li> </ul>"},{"location":"theory/#fundamental-concepts","title":"Fundamental Concepts","text":"<p>TO BE IMPLEMENTED</p>"},{"location":"theory/#api-reference","title":"API Reference","text":"<p>For more details on implementation, see the API Reference.</p>"},{"location":"theory/energy_life/","title":"Energy-Life","text":"<p>TO BE IMPLEMENTED</p>"},{"location":"theory/strain_life/","title":"Strain-Life","text":"<p>TO BE IMPLEMENTED</p>"},{"location":"theory/stress_life/","title":"Stress-Life","text":"<p>TO BE IMPLEMENTED</p>"}]}